回收方法区：
    也就是永久代，主要是回收废弃常量和无用的类。判断一个常量是否是废弃常量很简单，比如：
字符串常量池“abd”，没有任何String对象引用常量池中的“abd”，也没有其他地方引用了这个字面量
。而要判断一个类是否是无用的类的条件则是苛刻许多，需要同时满足以下三个条件
1：该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例
2：加载该类的ClassLoader已经被回收。
3：该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射范文该类的方法。

是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgc参数进行控制，还可以使用-verbose:class
以及 -XX:+TranceClassLoading, -XX:+TraceClassUnLoading查看类加载和卸载信息。在大量使用反射，
动态代理，CGLib等ByteCode框架/动态生成JSP以及OSGI这类平凡自定义CLASSLOADER的场景
都需要虚拟机具备类卸载的功能，以保证永久代不会溢出




垃圾回收算法：
一：标记-清除算法：
   一个是这样效率不高，算法分为标记和清除两个步骤
   二个是：空间问题，这样会造成大量不连续的碎片

二：复制算法
    为了解决效率问题，该算法将可用内存容量分为两块，只使用其他一块，每次回收时，都把还存活的对象
复制到另外一块，然后把自己使用过的空间依次性清理掉，这样每次清理时都是对整个半区进行回收
，内存分配时也不用考虑碎片问题。《深入理解JAVA虚拟机》 P70
  因为新生代大多数对象都是朝生夕死的，所以内存分配时不用分成1：1，而时将内存分为一块较大的Eden
空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor
中还存活的对象一次性的复制到另外一块survivor上面，最后清理掉Eden和刚才用过的Survivor。比例为
8：1：1，只有百分之10的内存被浪费

三：标记-整理算法

  复制收集算法在对象存活率教高的时候就要进行教多的复制操作，效率会降低。这时提出了标记-整理
算法，标记的过程还是和标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，二十让
所有存活的对象都像一端移动，然后直接清理掉端边界以外的内存

四：分代收集算法：
   新生代对象存活率比较低多用复制，老年代因为对象寻获率比较高，就必须使用标记-清理/标记-整理算法



枚举根结点

安全点

安全点的选定基本上是以程序“是否具有长时间执行的指令”为标准选定的，
“长时间执行”的最明显特征就是指令列复用
例如方法调用，循环跳转，异常跳转等

安全区域

当线程本身处于处于sleep状态或者Blocked状态时，无法响应JVM的终端请求
安全区域时指在一段代码中，引用关系不会发生变化。在这个区域中任意地方开始GC都是安全的
在线程执行到安全区域时，首先标识了自己进入了安全区域。线程要离开安全区域时，它要检索GC是否完成，如果
没有完成，要等完成了再离开安全区域


内存的分配余回收策略


对象有限在Eden分配

大对象直接进入老年代

长期存活的对象进入老年代
-XX:MaxTenuringThreshold设置，默认15
动态对象年龄判定
如果在survivor空间中相同的所有对象大小的总和大于survivor空间的一半，年龄待遇或等于该年龄的对象就可以直接
进入老年代，无需等到MaxTenuringThreshold中要求的年龄

空间分配担保



JDK命令行工具

jps:虚拟机进程状况工具
jstat:虚拟机统计信息监视工具
jinfo：JAVA配置信息工具
jmap:java内存映像工具
jhat:虚拟机堆转储快照分析工具
Jstack：Java堆栈跟踪工具
HSDIS：JIT生成代码反汇编



优化案例分析与实战
高性能硬件上的程序部署策略
      使用负载均衡

堆外内存导致的溢出错误
         GC会GC堆外内存，但是堆外内存不能主动触发GC，这里就要考了缓存策略，以及
使用第三方插件管理缓存，例如ehchache

外部命令导致系统变慢
     Runtime.getRuntime().exec()方法执行命令，这样在java虚拟机中时非常消耗资源的操作
，即使外部命令本身很快就能执行完，频繁调用时创建进程的开销也非常可观。Java虚拟机执行
这个命令的过程时，首先克隆一个和当前虚拟机拥有一样环境变量的进程，在用这个新的进程去执行外部命令，最后再推出
这个进程。类似这样的命令，考虑用Java的API去获取这些信息。 

服务器JVM进程崩溃
      （异步调用时间长了，可能会积累很多请求，导致在等待的线程和Socket链接越来越多，最终在超过服务器
承受能力的时候导致崩溃）
用生产者消费者模式取代异步调用

不恰当数据结构导致内存占用过大
    LONG与long


