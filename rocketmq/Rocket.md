# RocketMQ基本理论及架构

## 一、前置知识

### 链式调用和木桶理论

![](Rocket.assets/木桶理论.png)

### 引入MQ

![](Rocket.assets/引入MQ.png)

## 二、MQ前置知识

### MQ作用

消息队列作为高并发系统的核心组件之一，能够帮助业务系统解耦提升开发效率和系统稳定性。主要具有以下优势

- 削峰填谷（大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃）
- 系统解耦（解决不同重要程序，不同能力级别系统之间依赖导致一死全死）
- 提升性能（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）
- 蓄流压测（线上有些链路不好压测，可以通过堆积一定量消息再放开来压测）

### 应用场景

- 日志监控：作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低
- 推送消息：为社交应用和物联网应用提供点对点推送
- 金融报文：发送金融报文，实现金融准实时的报文传输，可靠安全
- 电信信令：将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。

#### 1、异步处理

场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种：

**串行处理**

1. register ---------------50ms
2. send mail ------------50ms
3. send msg ------------50ms

**并行模式**

1. register ---------------50ms
2. 多线程，线程1send mail -----------50ms，线程2send msg------------50ms

**消息中间件**

1. register ---------------50ms
2. 写入消息队列--------1ms

按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是 50 毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是 50 毫秒。因此架构改变后，系统的吞吐量提高到每秒 20 QPS。比串行提高了 3 倍，比并行提高了两倍。

#### 2、应用解耦

场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。

**传统模式的缺点：**假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合

**引入消息中间件**：

1. 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
2. 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作

#### 3、流量削峰

1、地铁早高峰

2、高铁春运

**排队，如果所有人都进去了，地铁站和高铁站就瘫痪了**

流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。 应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

**用户请求------->消息队列<--------秒杀业务处理**

用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。 秒杀业务根据消息队列中的请求信息，再做后续处理

#### 4、日志处理

日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。架构简化如下

日志采集客户端 -------->KAFKA消息队列<--------日志处理应用

日志采集客户端，负责日志数据采集，定时写受写入 Kafka 队列， Kafka 消息队列，负责日志数据的接收，存储和转发 日志处理应用：订阅并消费 kafka 队列中的日志数据

#### 5、消息通讯

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等 点对点通讯：

客户端 A ----------->消息队列<-----------客户端B

聊天室通讯

​                ----------->消息队列<-----------

客户端 A                                                客户端B

​                < -----------消息队列----------->

客户端 A，客户端 B，客户端 N 订阅同一主题，进行消息发布和接收。实现类似聊天室效果。

以上实际是消息队列的两种消息模式，点对点或发布订阅模式。

### 示例

#### 电商系统

![](Rocket.assets/电商系统示例.png)

消息队列采用高可用，可持久化的消息中间件。比如 Active MQ，Rabbit MQ，RocketMq。

#### 日志收集系统

![](Rocket.assets/日志收集系统示例.png)

#### 事务处理

![](Rocket.assets/事务处理.png)

### MQ对比

目前主流的MQ主要是

ZeroMQ

推特的Distributedlog

ActiveMQ:Apache旗下老牌消息引擎

RabbitMQ、Kafka：AMQP的默认实现

RocketMQ

Artemis：Apache的ActiveMQ下的子项目

Apollo：同样为Apache的ActiveMQ的子项目的号称下一代消息引擎



#### ActiveMQ

**单机吞吐量：万级**

**时效性：ms级**

**可用性：高，基于主从架构实现高可用**

**消息可靠性：有较低的概率丢失数据**

**功能支持：MQ领域的功能及其完备**

总结：

1. 非常成熟，功能强大，在早些年业内大量的公司及项目中都有应用
2. 偶尔会有较低的概率丢失数据
3. 现在社区以及国内应用都越来越少，官方社区现在对 ActiveMQ 5.x 维护越来越少，几个月才发布一个版本
4. 主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用

#### RabbitMQ

单机吞吐量：万级

topic数量对吞吐量的影响

时效性：微秒级，延时低是一大特点。

可用性：高，基于主从架构实现高可用性

功能支持：基于 erlang 开发，所以并发能力很强，性能极其好，延时很低

总结：

1. erlang 语言开发，性能极其好，延时很低
2. 吐量到万级，MQ 功能比较完备
3. 开源提供的管理界面非常棒，用起来很好用
4. 社区相对比较活跃，几乎每个月都发布几个版本分
5. 在国内一些互联网公司近几年用 rabbitmq 也比较多一些 但是问题也是显而易见的，RabbitMQ 确实吞吐量会低一些，这是因为他做的实现机制比较重。
6. erlang 开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug
7. rabbitmq 集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是 erlang 语本身带来的问题。很难读源码，很难定制和掌控。

#### RocketMQ

单机吞吐量：十万级

消息可靠性：消息0丢失

topic数量对吞吐量的影响：topic 可以达到几百，几千个的级别，吞吐量会有较小幅度的下降。可支持大量 topic 是一大优势。

时效性：ms 级

可用性：非常高，分布式架构

消息可靠性：经过参数优化配置，消息可以做到 0 丢失

功能支持：MQ 功能较为完善，还是分布式的，扩展性好

总结：

1. 接口简单易用，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是 ok 的，还可以支撑大规模的 topic 数量，支持复杂MQ 业务场景
2. 而且一个很大的优势在于，源码是 java，我们可以自己阅读源码，定制自己公司的 MQ，可以掌控
3. 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码

相比于其他的 mq 消息中间件具有主要优势特性有：

- 支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，rabbitmq 和 kafka 不支持）
- 支持结合 rocketmq 的多个系统之间数据最终一致性（多方事务，二方事务是前提）
- 支持 18 个级别的延迟消息（rabbitmq 和 kafka 不支持
- 支持指定次数和时间间隔的失败消息重发（kafka 不支持，rabbitmq 需要手动确认）
- 支持 consumer 端 tag 过滤，减少不必要的网络传输（rabbitmq 和 kafka 不支持）
- 支持重复消费（rabbitmq 不支持，kafka 支持

#### Kafka

单机吞吐量：十万级，最大的优点，就是吞吐量高。

topic 数量都吞吐量的影响：topic 从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka 尽量保证 topic 数量不要过多。如果要支撑大规模 topic，需要增加更多的机器资源

时效性：ms 级

可用性：非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用

消息可靠性：经过参数优化配置，消息可以做到 0 丢失

功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用

总结：

1. kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展
2. 同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量
3. kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略

#### 对比表

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                  | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- | ------------------------------------------------------------ |
| 开发语言   | java                                                         | erlang                                                       | java                      | scala                                                        |
| 单机吞吐量 | 万级                                                         | 万级                                                         | 十万级                    | 十万级                                                       |
| 时效性     | ms级                                                         | us级                                                         | ms级                      | ms级以内                                                     |
| 可用性     | 高（主从架构）                                               | 高（主从架构）                                               | 非常高（分布式架构）      | 非常高（分布式架构）                                         |
| 功能特性   | 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 | 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富 | MQ 功能比较完备，扩展性佳 | 只支持主要的 MQ 功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广 |



### 缺点

一个使用了 MQ 的项目，如果连这个问题都没有考虑过，就把 MQ 引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！ 回答:回答也很容易，从以下两个个角度来答：

1. 系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低
2. 系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。

既然有这些缺点，那么是不是不敢使用 MQ 了呢？答案很明显，不是，为了提高项目的性能，构建松耦合、异步的结构，必须要使用 MQ.

### 产品选型

我们在进行中间件选型时，一般都是通过下面几点来进行产品选型的：

1. 性能
2. 功能支持程度
3. 开发语言（团队中是否有成员熟悉此中间件的开发语言，市场上次语言的开发人员是否好招）
4. 有多少公司已经在生产环境上实际使用过，使用的效果如何
5. 社区的支持力度如何
6. 中间件的学习程度是否简单、文档是否详尽
7. 稳定性
8. 集群功能是否完备

如果从以上 8 点来选型一个消息队列，作为一名熟悉 java 的程序员，当遇到重新选择消息队列的场景时，我会毫不犹豫的选型 rocketmq，rocketmq 除了在第 6 点上表现略差(文档少，学习成本高)以及监控管理功能不友好外，从其它方面来说，它真的是一款非常优秀的消息队列中间件。

## 三、RocketMQ基本理论

### 发展历史

参考RocketMQ的前世今生

阿里巴巴消息中间件起源于2001年的五彩石项目，Notify在这期间应运而生，用于交易核心消息的流转。

至2010年，B2B开始大规模使用ActiveMQ作为消息内核，随着阿里业务的快速发展，急需一款支持顺序消息，拥有海量消息堆积能力的消息中间件，MetaQ 1.0在2011年诞生。

到2012年，MetaQ已经发展到了MetaQ 3.0，并抽象出了通用的消息引擎RocketMQ。随后，将RocketMQ进行了开源，阿里的消息中间件正式走入了公众的视野。

到2015年，RocketMQ已经经历了多年双十一的洗礼，在可用性、可靠性以及稳定性等方面都有出色的表现。与此同时，云计算大行其道，阿里消息中间件基于RocketMQ推出了Aliware MQ 1.0，开始为阿里云上成千上万家企业提供消息服务。

MetaQ在2016年双十一承载了万亿级消息的流转，跨越了一个新的里程碑，同时RocketMQ进入Apache 孵化。

### 消息存储

Topic 是一个逻辑上的概念，实际上 Message 是在每个 Broker 上以 Queue 的形式记录。

![](Rocket.assets/RocketMQ消息存储.png)

从上面的图可以总结一下几条结论

1. 消费者发送的 Message 会在 Broker 中的 Queue 队列中记录
2. 一个 Topic 的数据可能会存在多个 Broker 中
3. 一个 Broker 存在多个 Queue

也就是说每个 Topic 在 Broker 上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据，但是保存的消息数据实际上不是真正的消息数据，而是指向 commit log 的消息索引



### 消息发送

一个消息从发送，到接收，最简单的步骤：producer,topic,consumer,先由简单到复杂的来理解它的一些核心概念

**producer------------>Topic--------------->consumer**

消息先发到 Topic，然后消费者去 Topic 拿消息。只是 Topic 在这里只是个概念，那它到底是怎么存储消息数据的呢，这里就要引入 Broker 概念。

### 细化流程

![](Rocket.assets/消息发送消费流程.png)

总结：

1. 消息发送者服务集群：构成一个消息发送者组
2. 消息发送者组根据主题（topic）发送消息，先确定主题，然后才能在这个主题下创建消息队列，从而可以向此主题下的消息队列发送消息。
3. 消息消费者组：只能消费一个topic类型的消息
4. 一个topic可以被多个消费者组所消费

### 消息消费

![](Rocket.assets/1586447251(1).jpg)

#### 广播模式

![](Rocket.assets/1586447204(1).jpg)

每一条消息被每一个消费者都消费一次

注：不能违背基本模型，一个消费者组只能消费一个topic

#### 集群消费

消息队列中的消息被consumer消费后，消息还一直存在，没有消失，如何避免这条消息被不同的的消费者重复消息？？？？

**解决方案，把queue分配给不同的消费者，一旦分配，此队列不能被其他消费者所消费**

![](Rocket.assets/防止重复消费.png)

**平均分配算法**

10个队列，平均分配给4个消费者，用10除以4，除不尽有余数，余2

consumer1 : 2

consumer2 : 2

consumer3 : 2

consumer4 : 2

剩下两个，再从第一个消费者开始顺序分配

**环形平均算法**

![](Rocket.assets/1586448015(1).jpg)

**就近机房分配**

阿里云服务可以提供