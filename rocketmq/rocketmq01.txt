为什么要学习MQ?
	

mq产品选型

面试问题
	什么场景要使用MQ?直接调接口不行吗
	
	Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别
	
	
为什么使用MQ中间件？？？-----消息中间件在实战应用中到底有什么重要作用


	链式调用存在什么样的问题？？？
	A B,A C, A D 同步阻塞调用方式，一旦B服务执行时间过长，导致服务雪崩，从而导致整个服务不可用
	因为B服务出问题，导致C,D服务调用不到
	
	怎么解决这个问题？引入消息中间件
	
	MQ作用（高并发，大流量）
		削峰填谷
		
		系统解耦（解决不同重要程序，不同能力级别系统之间依赖导致一死全死）
		
		提升性能
		
		蓄流压测   在消息中间件积压大量消息，来测试服务的性能
		
	应用场景：
		日志监控
		消息推送
		金融报文
		电信信令
		
	
	以往代码结构（串行化） 150ms
		1、register              50ms
		2、send email            50ms
		3、send message          50ms
		
	并行模式  100ms
		1、register ---> 多线程 ---->send mail    50ms
		                 多线程 ---->senf msg     50ms
						 
	消息中间件   55ms
	     1、register ----->写入消息队列 。。。。。5ms           send mail和send msg的动作与消息队列打交道
		 
		 
	
	消息队列-应用解耦
		传统模式的缺点：加入库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合
	
	引入消息中间件
		订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
		
		库存系统：订阅下单的消息，采用推拉的方式，获取下单信息，库存系统根据下单信息，进行库存操作
		
		
	流量削峰
		1、地铁早高峰
		2、高铁春运
		排队，如果所有人都进去了，地铁站和高铁站就瘫痪了
		
		用户请求------->消息队列<--------秒杀业务处理
		
		
	日志处理
		日志处理主要用kafka
		
			日志采集客户端 -------->KAFKA消息队列<--------日志处理应用
			
		消息通讯
		
		
		日志收集系统
		
		事务处理
			分布式事务
			
				A银行和B银行需要达到数据一致性
					通过MQ来处理？
					最终消息一致性，处理分布式事务
					
		
		主要作用：
			流量削峰
			服务解耦
			分布式事务----最终消息一致性
			
			
		MQ具体有哪些产品：
			推特的Distributedlog
			RabbitMQ、Kafka：AMQP的默认实现
			ActiveMQ：Apache旗下的老牌消息引擎
			RocketMQ：阿里巴巴旗下的消息中间件，已经被apache收购了，已经经过了阿里巴巴双11的考验，可以放心大胆的使用
			Artemis:Apache的ActiveMQ下的子项目
			Apollo：同样Apache的ActivMQ的子项目，号称下一代消息引擎
			ZeroMQ
			IronMQ
			OpenMQ
		
		消息中间件都有神马特性？
			ActiveMQ
				单机吞吐量：万级
				时效性：ms级
				可用性：高，基于主从架构实现高可用
				消息可靠性：有较低的概率丢失数据
				功能支持：MQ领域的功能及其完备
				总结：
					非常成熟，功能强大，在早些年业内大量的公司及项目中都有应用
					偶尔会有较低的概率丢失数据
			RabbitMQ：
				单机吞吐量：万级
			
			RocketMQ：（java语言开发）
				单机吞吐量：十万级
			    消息可靠性：消息0丢失
			Kafka（scala语言开发）
				单机吞吐量：十万级，最大的优点，就是吞吐量高
				topic数量吞吐量的影响：从几十个到几百个时，性能大幅下降，所以kafka一般用在专业的领域，一般用在日志领域，一般在业务上不建议使用
				时效性：ms级别
				可靠性：
				
				
			对比：有一个表格，作为一个架构师，直接上RocketMQ就完了？
			
				rabbitMQ：主从架构
					1、最低需要2台服务器
					2、低延时
				RocketMQ：分布式架构
					最低需要4台服务（两台server，两台broker）
					2、消息堆积能力强，因为单机吞吐量：10万级别
		
		但是现在都是云时代了，我们已经不在乎要使用几台机器了--------> 可以使用RocketMQ，可以在本公司构建私有云，购买阿里云，容器化的方式运行消息中间件
		云原生：统一使用性能更强劲的消息中间件。
		什么是云原生，在将K8S的时候，就会将到云原生
		
		
		思考：架构师，在项目中，使用消息中间件优缺点？？？
			一项技术不能为了使用而使用。如果不思考这个问题，就不是一个合格的架构师
			如何选择一款软件
			思考：项目运行良好，非常流畅，并发压力增大后，考虑引入在项目中引入MQ消息中间件？？----风险
				1、单点故障（消息中间件宕机）----整个服务不可用，额外的增加了风险
				2、本地事务就可以控制数据的一致性，一旦加入了MQ消息中间件----处理数据一致性的问题，业务设计，架构设计变得非常复杂
				3、重复消息------接口幂等性设计
				总结：一旦引入了mq消息中间件，考虑数据一致性问题，接口幂等性问题，架构设计调整，整个业务系统变得非常复杂。
					如果团队技术能力不到位，解决这些问题变得非常危险
					
				思考：
					1、创业型公司，中小型企业----并发压力不大，架构思考是否使用中间件
					2、互联网公司----高并发压力---微服务架构-----引入mq消息中间件，流量削峰，服务解耦
					
				
				产品选型：
					性能
					功能支持程度
					开发语言
					
					
	选择RocketMQ:
		消息堆积能力比较强大
		消息时效性ms
		分布式架构，消息可靠性非常强
		使用java语言开发，有问题可以参考源码
		
		
RocketMQ发展历史
	阿里巴巴消息中间件起源于2001年的五彩石项目，Notify在这期间应运而生，用于交易核心消息的流转。
	2010年，B2B开始大规模使用ActiveMQ作为消息内核，随着阿里业务的快速发展，继续一款支持顺序消息，拥有
	海量消息堆积能力的消息中间件，MetaQ1.0在2011但是
	
	2012年。。。
	
	2015年，RocketMQ已经经历了多年双十一的洗礼，在可用性，可靠性以及稳定性等方面都有出色的表现。与此同时
	
	2016年
	
	
	
	消息存储：
		消息逻辑结构：topic（主题） ---一类消息
			1、一个topic（主题）有多个消息队列
			2、消息队列进行分片存储，消息队列会分布在多个broker服务器进行存储
			3、一个topic数据可能存储在多个broker服务器
			
			
		点对点模式

		发布订阅模式
		
		
		RocketMQ消息发送及消费模式：（和Actice与RabbitMQ的区别）
		
			Rocket只有一种模式：主题模式（topic模式）
			
			producer------>Topic--------------->consumer
			发送及消费的原理
			
			
		
		
		消息发送者组发送消息：
			1、确定消息类型----消息主题（topic）
			2、可以向此topic主题下的队列发送消息
			注意：消息最终还是发送到队列中，注意，队列是在主题的下面，一个主题对应多个消息队列
			问题：一个消息生成者组，可以发送多个主题的消息吗？
			答案：可以，根据业务来确定的、
			
			多个消费者组是否可以消费同一个主题？
			答案：是可以的，多个消费者可以消费同一个topic
			
			同一个消费者组，是否可以同时消费多个topic的消息？
				不行！！！！！
				由于消费负载均衡的算法问题，导致一部分消息无法被消费
				
				
				pull和push的区别，没有区别，在底层都是调用的pull
				
				
	总结：消息发生者服务集群构成了消息发送者组
		  消息发送者组根据主题（topic：类型）发送消息，先确定主题，然后才能在这个主题下创建消息队列，从而可以向此主题下的
		  消息队列发送消息
		  消息消费者组：只能消费一个类型的消息
		  一个topic可以被多个消费者组所消费的
		  
		  
	消息发送及消息接收的负载均衡
	消息发送策略
		默认策略：随机递增取模
				  轮询算法
				  随机
				  就近机房------没有实现
	消息消费：
		广播模式：每一条消息被每一个消费者消费
		集群模式：
				平均分配
				环形平均
				就近机房分配-----接口
			
	消息队列中的消息被consumer消费后，消息还一直存在，没有消失，如何避免这条消息被不同的的消费者重复消息？？？？
	
	解决方案，把queue分配给不同的消费者，一旦分配，此队列不能被其他消费者所消费
			
		平均分配算法：
			10个队列，平均分配给4个消费者，用10除以4，除不尽有余数，
			consumer1 : 2
			consumer2 : 2
			consumer3 : 2
			consumer4 : 2
			剩下两个，再从第一个消费者开始顺序分配
		环形平均分配算法
			把队列排成环形，1,2,3,4,1,2,3,4,1，2,
		临近机房算法：
			阿里云服务可以提供
			
			
	
				
			
			·
				
		