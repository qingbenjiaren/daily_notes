# 第一部分 基础知识

## 线程安全性

如果当多个线程访问同一个可变的状态变量时没有使用同步，那么程序就会出现错误。有三种方式可以修复这个问题：

- 不在线程之间共享该状态变量
- 将状态变量修改为不可变的变量
- 在访问状态变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

### 什么是线程安全性

**当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。**

而正确性的含义是：某个类的行为与其规范完全一致。

如果某个类在单线程环境中都不是正确的，那么它肯定不会是线程安全的。

在线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。

由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象一定是线程安全的。

大多数servlet都是无状态的，从而极大地降低了在实现servlet线程安全性时的复杂性，只有当servlet在处理请求时需要保存一些信息时，线程安全性才会使一个问题。

### 原子性

虽然递增操作 ++i 是一种紧凑地语法，使其看上去是一个操作，但是这个操作并非是原子的，因为它并不会作为一个不可分割的操作来执行。实际上，它包含了三个独立的操作：读取 i 的值，将值加1，然后将计算结果写入到 i 。这是一个“读取 - 修改 - 写入”的操作序列，并且其结果状态依赖于之前的状态。

#### 竞态条件

最常见的竞态条件是“先检查后执行(Check-Then-Act)”，即通过一个可能失效的观测结果来决定下一步的动作。

这里有个著名的“星巴克约会问题”。假定你计划中午在University Avenue的星巴克与一位朋友会面。当你到达那里的时候，发现在University Avenue上有两家星巴克，并且并没有约定到具体哪一家。。。。。。可以脑补一下。除非你们之间约定了某种协议，否则你们整天都在University Avenue上走来走去，倍感沮丧。

在星巴克这个示例中说明了一种竞态条件，因为要获得正确的结果（于朋友会面），必须取决于事件发生的时序（当你们到达星巴克时，在离开并去另一家星巴克之前会等待多长时间）。当你迈出前门时，你在星巴克A的观察结果将变得无效，你的朋友可能从后门进入，而你却不知道。这种观察结果的失效就是大多数静态条件的本质-----基于一种可能失效的观察结果做出判断或执行计算。

#### 延迟初始化中的竞态条件

使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。

```java
public class LazyInitRace{
    public ExpensiveObject instance = null;
    
    public ExpensiveObject getInstance(){
        if(instance == null){
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

> 不要这么做，存在竞态条件，它可能会破坏这个类的正确性

#### 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

在实际情况中，应尽可能地使用现有的线程安全对象(例如 AtomicLong)来管理类的状态。

### 加锁机制

