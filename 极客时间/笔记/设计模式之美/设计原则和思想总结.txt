代码质量评判标准

	如何评价代码质量高低
		可读性、可维护性、灵活、优雅、简洁
		我们并不能通过单一维度去评价一段代码的好坏。
	
	最常用的评价标准有哪几个？
		可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。
	
	如何才能写出高质量的代码？
		
		要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

面向对象

	面向对象概述
	
	面向对象四大特性
		
		封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。
		
		如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。
		
		继承用来表示类之间的 is-a 关系，继承主要是用来解决代码复用的问题。
		
		多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。
		
	面向对象 VS 面向过程
	
		对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
		
		面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
		
		从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。
		
	面向对象分析、设计与编程

		OOA：做什么
		OOD：怎么做
		OOP：编码
		
		需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。
		
		面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。
		
		划分职责进而识别出有哪些类根据需求描述，我们把其中涉及的功能点，
		
		定义类及其属性和方法
		
		定义类与类之间的交互关系
		
		将类组装起来并提供执行入口
		
	接口 VS 抽象类
		
	基于接口而非实现编程
		
		在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。
		好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。
		
	多用组合少用继承
		继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。
		
		尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。
		
		
		
		
	贫血模型 VS 充血模型
	
	

设计原则
	
	SOLID 原则：SRP 单一职责原则
		不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。
		
		出现下面这些情况就有可能说明这类的设计不满足单一职责原则：
		
			类中的代码行数、函数或者属性过多；
			类依赖的其他类过多或者依赖类的其他类过多；
			私有方法过多；
			比较难给类起一个合适的名字；
			类中大量的方法都是集中操作类中的某几个属性。
			
	SOLID 原则：OCP 开闭原则
	
		开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
		同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。
		
	SOLID 原则：LSP 里式替换原则
		
		理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”
		
		不改变原有程序的逻辑及不破坏原有程序的正确性。
		
	SOLID 原则：ISP 接口隔离原则
	
		客户端不应该强迫依赖它不需要的接口
		
	SOLID 原则：DIP 依赖倒置原则
		控制反转
		依赖注入
		依赖注入框架
		依赖反转原则
		
	KISS、YAGNI 原则
		
		对于如何写出满足 KISS 原则的代码，我总结了下面几条指导原则：
			
			不要使用同事可能不懂的技术来实现代码；
			
			不要重复造轮子，善于使用已经有的工具类库；
			
			不要过度优化。
		
		YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它
			
			不要去设计当前用不到的功能；
			不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。
		
		KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。
		
	DRY 原则
		
		不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码。
		
		实现逻辑重复、功能语义重复、代码执行重复。
		实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
		实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。而代码执行重复也算是违反 DRY 原则。
		
	LOD 原则
		高内聚，松耦合
		“高内聚”用来指导类本身的设计
		“松耦合”用来指导类与类之间依赖关系的设计
		
		如何理解“迪米特法则”？
		
			不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。
			
		
规范与重构
	重构概述
		重构的目的：为什么重构（why）？
		
			重构可以保持代码质量持续处于一个可控状态，
		
		重构的对象：重构什么（what）？
			
			大规模
			
			小规模
			
		重构的时机：什么时候重构（when）？
		
			建立持续重构意识
			
		重构的方法：如何重构（how）？
			大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。
			
			而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。
			
	单元测试
		编写单元测试尽管繁琐，但并不是太耗时；
		我们可以稍微放低单元测试的质量要求；
		覆盖率作为衡量单元测试好坏的唯一标准是不合理的；
		写单元测试一般不需要了解代码的实现逻辑；
		单元测试框架无法测试多半是代码的可测试性不好。
		
	代码的可测试性
		
		什么是代码的可测试性？
			
			编写单元测试的难易程度
			如果很难为其编写单元测试，那往往就意味着代码设计得不够合理，代码的可测试性不好
		编写可测试性代码的最有效手段
			依赖注入
			mock
		常见的 Anti-Patterns
			
			代码中包含未决行为逻辑；
			滥用可变全局变量；
			滥用静态方法；
			使用复杂的继承关系；
			高度耦合的代码。
			
	大型重构：解耦
		
	
	小型重构：编码规范
	
	
	命名与注释
	
	代码风格
	
	
	编程技巧	
		将复杂的逻辑提炼拆分成函数和类；
		
		通过拆分成多个函数的方式来处理参数过多的情况；
		
		通过将参数封装为对象来处理参数过多的情况；
		
		函数中不要使用参数来做代码执行逻辑的控制；
		
		移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数；
		
		用字面常量取代魔法数；
		
		利用解释性变量来解释复杂表达式。