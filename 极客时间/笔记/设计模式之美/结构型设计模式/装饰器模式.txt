InputStream in = new FileInputStream("/user/wangzheng/test.txt");
InputStream bin = new BufferedInputStream(in);
byte[] data = new byte[128];
while (bin.read(data) != -1) 
{ //...}


Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？


组合优于继承

那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。

	
	第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
	
	第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。
	
	代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。
	
	装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。
	
	它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。
	
	除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。
	
	为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
	
	
	对于“添加缓存”这个应用场景来说，我们到底是该用代理模式还是装饰器模式呢？你怎么看待这个问题？
	
	
	
	答：若添加缓存与本身业务逻辑无关（即添加缓存这个动作，与本身逻辑的正确执行无关）且是通用性的功能，推荐使用的是代理模式
	    若添加缓存跟本身业务逻辑的处理相关（参与该动作且会影响该动作的输出），且不是通用性的功能，适合使用装饰模式