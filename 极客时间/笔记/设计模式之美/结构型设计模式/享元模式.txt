不常用

原理和设计很简单


原理与实现
	享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
	
	如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。
	
	不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。
	
	“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了
	
	不可变对象不能暴露任何 set() 等修改内部状态的方法。
	
	绝地求生需要打很多子弹出去，子弹中的某些不可变属性可以提出来享元
	
	棋牌游戏中的棋子也是一样，上百万对局中，棋子的某些属性可以享元
	
	
	文本编辑器？字体格式享元
	
	享元模式的实现
		
		享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。
	
	享元和单例的区别
	
		实际上享元有点类似单例的变体多例，
		单例只能创建一个对象，享元能创建多个对象
		
		区别两种模式，需要看设计意图，享元是为了对象复用，单例是为了限制对象个数
		
	享元和缓存的区别
		
		享元是为了复用，而平时所讲的缓存（CPU缓存，数据库缓存，MemCache缓存）主要是为了提高访问效率
		
	享元模式跟对象池的区别
	
		对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？
		
		池化技术中的复用主要目的是节省时间，比如从数据库连接池中取一个连接，不需要新创建（重复使用）
		
		享元模式的复用主要目的是节省空间，在整个生命周期中，都是被使用中共享（共享使用）
		
	
剖析享元模式：
	Integer用到了享元模式来复用对象，当我们通过自动装箱，也就是调用valueOf()来创建Integer对象的时候，如果要创建的Integer对象值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建
	
	public static Integer valueOf(int i) {
		if (i >= IntegerCache.low && i <= IntegerCache.high) 
			return IntegerCache.cache[i + (-IntegerCache.low)]; 
		return new Integer(i);}
		
	实际上，这里的 IntegerCache 相当于，我们上一节课中讲的生成享元对象的工厂类，只不过名字不叫 xxxFactory 而已。我们来看它的具体代码实现。这个类是 Integer 的内部类，你也可以自行查看 JDK 源码。
	
	
	为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？
	
	在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）。
	
	实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果你通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，你就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没有提供设置最小值的方法。
	
	//方法一：-Djava.lang.Integer.IntegerCache.high=255
	//方法二：-XX:AutoBoxCacheMax=255
	


切记，切记，this is personal, oh my god this is personal , i am not a foolish
it is simple, but its mine,it is mine baby	
个人理解，实际上享元模式不是为了要在-127到128之间用"=="来判断值是否相等，而是为了复用对象而已，而使用"=="去判断对象相等本身就是不正确的，只不过因为Integer用到了享元，导致得到了符合预期的答案而已，但是这属于，逻辑错误结果正确（在-127到128之间结果正确），而在-127到128之外，则是逻辑错误结果也错误.

在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。
Integer a = new Integer(123);
Integer a = 123;
Integer a = Integer.valueOf(123);


享元模式在java string中的应用

	字符串常连池
	
	String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。
	
	
实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉

除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模式，得不偿失啊。
		