为什么需要单例设计模式？解决了什么问题？

如何实现一个单例
	
	构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
	
	考虑对象创建时的线程安全问题；
	
	考虑是否支持延迟加载；
	
	考虑 getInstance() 性能是否高（是否加锁）。
	
1、饿汉式
	
	在类加载的时候单例对象就创建并初始化好了，线程安全。不支持延迟加载
	不支持延迟加载并不意味着不好
		
		认为不好的观点：
			
			如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。
		
		不一样的观点：
			
			对于初始化耗时过长的实例，如果等到要用的时候再加载会影响系统的性能（
			在响应客户请求的时候，做初始化操作会导致请求时间变长，甚至超时）
			
			另外可以在项目启动的时候就发现实例初始化的问题，而不是隐藏起来用的时候再暴露
			
			如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

2、懒汉式
	
	支持延迟加载，需要加锁，不支持高并发

3、双重检测
	
	支持延迟加载，支持高并发
	
	网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。
	要解决这个问题，我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）
	
4、静态内部类
	
	简单，类似饿汉式，延迟加载，不用手动加锁，线程安全，由JVM保证
	
5、枚举
	


单例模式？反模式？

单例模式存在哪些问题：
	
	硬编码
	
	单例对OOP特性支持不友好
	
	单例会隐藏类之间的依赖关系
	
	单例对代码的扩展性不友好
	
		如果需要多个实例，就需要改代码
			比如：数据库连接池，将慢SQL和普通SQL隔离开，让慢SQL独享一个数据库连接池
			这时，设计成单例类就不能满足需求的变更
	
	单例对代码的可测试性不友好
	
	单例不支持有参数的构造函数
	
单例有什么替代解决方案？
	
	静态方法
	
	工厂
	
	IOC
	
	自己保证
	
说单例是反模式，有点极端，模式没有对错，关键看使用场景


如何理解单例模式中的唯一性
	
	对象唯一性的作用域：进程唯一，进程之间不共享地址空间
	
如何实现线程唯一的单例
	
	线程内唯一，线程间不唯一，进程唯一，线程不唯一
	
		HashMap<线程ID，对象>
		ThreadLocal
		
如何实现集群唯一的单例
	
	进程内唯一，进程间也唯一
	
	有难度！
	
	把单例对象序列化，储存到外部共享储存区，
	一个对象在获取到对象后，需要对对象加锁

如何实现多例对象
	
	一个类可以创建多个对象，但是对象的个数是有限制的
	
	同一类型只能创建一个对象
	不同类型的创建多个对象
	
	类似工厂模式，只不过工厂模式创建的是不同的对象
	
	

	