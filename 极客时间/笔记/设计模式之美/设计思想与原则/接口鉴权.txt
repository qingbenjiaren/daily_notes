面向对象分析
面向对象设计
面向对象编程

微服务通过 HTTP 协议暴露接口给其他系统调用，说直白点就是，其他系统通过 URL 来调用微服务的接口。

如何实现接口鉴权

无法下手

原因
	需求不明确，
		leader 给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。
		这也是真实的软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不是很明确。
		
		面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”
		实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行
		我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。
		
	缺少锻炼
		相比单纯的业务 CRUD 开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。
		而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。
		
		开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。
		如果你平时做的都是简单的 CRUD 业务开发，那这方面的锻炼肯定不会很多，所以，一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。
	
对案例进行需求分析
	先从最简单的方案想起，然后在优化。所以，可以做多轮分析，每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表
	
	第一轮基础分析
		接口鉴权功能，最简单的解决方案就是，通过用户名加密码来做认证。
		调用方每次进行接口请求的时候，都携带自己的APPID和密码。
		微服务在接收到接口调用请求后，会解析出AppID和密码，跟存储在微服务端的AppId和密码进行比对。
		
	第二轮分析优化
		不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？
		实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口。这就是典型的“重放攻击”。
		
		提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 OAuth 的验证思路来解决。
		调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。
		微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。
		
	第三轮分析优化
		不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码生成的 token 都是固定的。未认证系统截获 URL、token 和 AppID 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL 对应的接口。
		
		为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。
		
	第四轮分析优化
		不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！
		
		攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。
		
		所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。
		
		实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 AppID 和密码。
		
		针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。
		
	最终确定需求
	
		调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。
		
		微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。
		
		微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。
		
		如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。
		
	这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题 - 解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。
	
	
	
	
如何进行面向对象设计？

	面向对象分析的产出是详细的需求描述
	
	那面向对象设计的产出就是类，我们将需求描述转化为具体的类的设计
	
		划分职责进而识别出有哪些类；
		
		定义类及其属性和方法；
		
		定义类与类之间的交互关系；
		
		将类组装起来并提供执行入口。

		
		划分职责进而识别出有哪些类
			
			一：映射现实世界
			
			二：罗列需求描述中的名词罗列出来
			
			三：列出一个一个的功能点，然后再去看那些功能点职责类似，操作相同的属性，是否可归为一个类
			
			
			接口鉴权功能罗列
				
				首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。
				拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（单一职责）
				
				把 URL、AppID、密码、时间戳拼接为一个字符串；
				
				对字符串通过加密算法加密生成 token；
				
				将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；
				
				解析 URL，得到 token、AppID、时间戳等信息；
				
				从存储中取出 AppID 和对应的密码；
				
				根据时间戳判断 token 是否过期失效；
				
				验证两个 token 是否匹配；
	
	
				对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。
				类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。
	
					
					第一个细节：并不是所有出现的名词都被定义为类的属性，比如 URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。
					
					第二个细节：我们还需要挖掘一些没有出现在功能点描述中属性，比如 createTime，expireTimeInterval，它们用在 isExpired() 函数中，用来判定 token 是否过期。
					
					第三个细节：我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()。
					
					
					
					虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式来表达，还有可能是 Dubbo、RPC 等其他形式。
					为了让这个类更加通用，命名更加贴切，我们接下来把它命名为 ApiRequest。下面是我根据功能点描述设计的 ApiRequest 类。
	
				定义类与类之间的关系
				
					
	
	
				接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthenticator 接口类，暴露一组给外部调用者使用的 API 接口
				
				
				
	重点回顾
	
		面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计
		
		
		1. 划分职责进而识别出有哪些类
		
		2. 定义类及其属性和方法
		
		3. 定义类与类之间的交互关系
		
		4. 将类组装起来并提供执行入口
		
		
		
	
	