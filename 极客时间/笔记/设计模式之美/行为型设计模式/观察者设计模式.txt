创建型：解决对象的创建
结构型：解决类或对象的组合或组装
行为型：类或对象之间的交互

行为型设计模式比较多：
	观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。
	
	观察者模式在实际的开发中应用得比较多，有同步阻塞的实现方式，也有异步非阻塞的实现方式
	
	
	观察者模式也叫做发布订阅模式
		
		在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
	
	最经典的实现方式：
		抽象一个被观察者：Subject，有以下三个方法
			void registerObserver(Observer observer);
			void removeObserver(Observer observer);
			void notifyObservers(Message message);
			
		抽象一个观察者 Observer
			void update(Message message);
		
		具体的被观察者，实现方法
			private List observers = new ArrayList();
			
			public void notifyObservers(Message message) {
				for (Observer observer : observers) {
					observer.update(message);
				}
			}
		
		具体的观察者：接收通知，做对应的业务处理
		
	以上的设计方式和代码时观察者模式的"模板代码"，只能反映大体的设计思路。
	
	在真实的软件开发中，并不需要照搬上面的模板代码。
	
	观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的。
	
	
	应该注意培养抽象的能力，能抽象出观察者和被观察者能节省很多工作
	
	观察者可以是现实世界中的具体对象，也可以是抽象出来的对象
	
	实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。
	
	
	观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。
	
	
	以上的观察者模式是同步阻塞的
	
	也可以有异步的方式（参考spring 的监听器）
	
	Google Guava EventBus
	
	