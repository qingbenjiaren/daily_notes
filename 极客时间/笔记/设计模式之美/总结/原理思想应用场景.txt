一、创建型设计模式
	单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
	
	单利模式
		一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。
		
		饿汉式、懒汉式、双重检测、静态内部类、枚举。
		
		单利模式存在的问题
			
			单例对 OOP 特性的支持不友好
			单例会隐藏类之间的依赖关系
			单例对代码的扩展性不友好
			单例对代码的可测试性不友好
			单例不支持有参数的构造函数
		
		解决：通过工厂模式、IOC 容器来保证全局唯一性
		
		进程唯一单例、线程唯一单例、集群唯一单例、多例等扩展
		
	工厂模式
		工厂模式包括简单工厂、工厂方法、抽象工厂这 3 种细分模式。
		
		工厂模式的作用有下面 4 个，这也是判断要不要使用工厂模式最本质的参考标准。
		
			封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
			
			代码复用：创建代码抽离到独立的工厂类之后可以复用。
			
			隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
			
			控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
		
		经典的应用场景：依赖注入框架，比如 Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。
		
	建造者模式
		建造者模式用来创建复杂对象，可以通过设置不同的可选参数，定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。
		
		
		存在下面情况中的任意一种，我们就要考虑使用建造者模式了
			必填属性太多
			属性之间有一定的依赖关系或者约束条件
			创建不可变对象
		
	原型模式
		
		如果对象的创建成本比较大，而同一个类的不同对象之间差别不大
		
		深拷贝
		浅拷贝
	
二：结构型设计模式
	类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。
	代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。
	
	代理模式
		代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
		
		实现接口或继承来实现
		
		动态代理：在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
		
		代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。
		
		除此之外，代理模式还可以用在 RPC、缓存等应用场景中。
		
	
	桥接模式
		
		将抽象和实现解耦，让它们能独立开发
		组合优于继承
		
	
	装饰器模式
		
		装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。
		可以对原始类嵌套使用多个装饰器
		为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
		
	适配器模式
		
		将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。
		类适配器和对象适配器
		类适配器使用继承关系来实现，对象适配器使用组合关系来实现。
		
		适配器模式是一种事后的补救策略，用来补救设计上的缺陷
		
			封装有缺陷的接口设计
			
			统一多个类的接口设计
			
			替换依赖的外部系统
			
			兼容老版本接口
			
			适配不同格式的数据
			
				
				代码示例：ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。
				
					// 类适配器: 基于继承
					public interface ITarget {
					  void f1();
					  void f2();
					  void fc();
					}

					public class Adaptee {
					  public void fa() { //... }
					  public void fb() { //... }
					  public void fc() { //... }
					}

					public class Adaptor extends Adaptee implements ITarget {
					  public void f1() {
						super.fa();
					  }
					  
					  public void f2() {
						//...重新实现f2()...
					  }
					  
					  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
					}

					// 对象适配器：基于组合
					public interface ITarget {
					  void f1();
					  void f2();
					  void fc();
					}

					public class Adaptee {
					  public void fa() { //... }
					  public void fb() { //... }
					  public void fc() { //... }
					}

					public class Adaptor implements ITarget {
					  private Adaptee adaptee;
					  
					  public Adaptor(Adaptee adaptee) {
						this.adaptee = adaptee;
					  }
					  
					  public void f1() {
						adaptee.fa(); //委托给Adaptee
					  }
					  
					  public void f2() {
						//...重新实现f2()...
					  }
					  
					  public void fc() {
						adaptee.fc();
					  }
					}
		
	
	门面模式
		门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。
		
	组合模式
		主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。
		
		组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。
		
		数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现
		
		组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。
		
	享元模式
		所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
		
		当一个系统中存在大量重复对象的时候，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。
		
		对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。
		
三：行为型设计模式
	创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。
	
	观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。
	
	
		观察者模式
			
			观察者模式将观察者和被观察者代码解耦。
			
			小到代码层面的解耦，大到架构层面的系统解耦
			
			同步阻塞
			
			异步非阻塞
			
			进程内
			
			跨进程：消息队列
			
			框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发
			
			针对异步非阻塞观察者模式，我们也可以将它抽象成 EventBus 框架来达到这样的效果。
			
		模板模式
			复用和扩展
			
			继承和回调
				
				回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。
				
				回调可以细分为同步回调和异步回调。
				
				从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式
				
				回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上
		
		策略模式
			
			策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换
			
			对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。
			
		职责链模式
			
			在职责链模式中，多个处理器依次处理同一个请求，链条上的每个处理器各自承担各自的处理职责
			
			在 GoF 的定义中，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了
			
			请求不会中途终止传递，而是会被所有的处理器都处理一遍。
			
			职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能
			
		迭代器模式
			
			迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。
			
			遍历集合一般有三种方式：for 循环、foreach 循环、迭代器遍历。后两种本质上属于一种，都可以看作迭代器遍历
			
			相对于 for 循环遍历，利用迭代器来遍历有 3 个优势：
				
				迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；
				
				迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一
				
				迭代器模式让添加新的遍历算法更加容易，更符合开闭原则
			
			迭代器模式可能存在的问题，未决问题
				
				一种是遍历的时候不允许增删元素
				
				另一种是增删元素之后让遍历报错，fail-fast
			
		状态模式
			3 个部分组成：状态、事件、动作。其中，事件也称为转移条件
			
			针对状态机，我们总结了三种实现方式。
				
				第一种实现方式叫分支逻辑法，利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。
				
				第二种实现方式叫查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
				
				第三种实现方式就是利用状态模式。
		
		访问者模式(accept)
			访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。
				
			静态绑定
			
			Double Disptach
			
			正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差
			
		备忘录模式
			备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态
			
			快照
			
			主要用来防丢失、撤销、恢复等
			
			对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长
				
				只备份必要的恢复信息，结合最新的数据来恢复
				
				全量备份和增量备份相结合，低频全量备份，高频增量备份
		
		命令模式
			
			将函数封装成对象
			
		
		解释器模式
			
		
		中介模式
			
			中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）
			
			最小化对象之间的交互关系
			
			观察者模式和中介模式都是为了实现参与者之间的解耦
			
			在观察者模式的应用场景中，一个参与者只有一个身份，要么是观察者，要么是被观察者
			
			而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。
			
			
		
		