提供者发送给注册中心（服务端）的UP或者OUT OF SERVICE状态时，是不可信任的
因为老雷讲清楚了，因为STARTING和DOWN两种状态不会通过Actuator来修改
Actuator可能修改了提供者的状态，但是服务器并没有向提供者通知到位，所以这个时候
提供者不知道自己目前的状态，所以发出的状态是不可靠的


注意理解overridenState和提供者本身的state，他们并不等价

续约：


下架：

		又有一个时间戳了：
			lastUpdateTimestamp（心跳）
			
			
			老雷挖了个坑：
				写操作为什么要加个读锁
					read.lock()
				并且都是写操作，为什么续约就没有读锁
					加了读锁，别人可以读，但是不能写
					加了写锁，别人读都读不到了
					
					因为写操作如果加了写锁，别人就不能读了，renew都不能了
					所以加读锁，
					
					renew不加锁是考虑性能方面的因素
					若不加锁，确实会存在问题，
					但是这是一盘大棋，renew执行频率太高，加锁影响性能
					
					
定时清除过期的client
	openForTraffic
	
	老雷讲了半天，画了两幅图，说明白了补偿时间的问题
	这些东西再平时的开发过程中都是有作用的
	第一次是不需要补偿的
	
	注意不需要补偿的情况
	
	compensationTime
	
	如果没有开自我保护，就可以删除
	若开启了自我保护，直接return，自我保护机制默认是true
	
	
	删除的条件：
			
					当前时间 > lastUpdateTimestamp（心跳）+duration+补偿时间
					
					
					
				统计客户端数量，
				threashold = 客户端数量*0.85
				
				100 - 100*0.85
				是可以删除的数量
				
				若删除数量大于15个了，自我保护机制开启
				
				这里优点复杂，要高清除，需要再听一次老雷
				
				
				
下次讲openFeign和Ribbon


老雷良心课：录播后期会续上
