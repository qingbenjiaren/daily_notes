1 网络编程（java socket/io nio aio）
2 netty
3 springboot整合netty 数据通信、自定义协议

4 jvm(原理，组成部分,jvm h s p 算法、垃圾回收器，垃圾回收算法，
jvm调优，以及各种jvm工具 )

------------------------------------------------------------
网络直连与消息中间件的区别来了，
neety：如果生产者效率较高而消费者消费能力较弱，
就会出现在消费者缓存中堆积大量的任务造成内存崩溃
并且如果消费者挂了，缓存中的任务还可能会丢失
消息中间件就不存在这个问题，生产者只需要把消息发送到mq中

目录：
学习基本概念、传统的同步阻塞式IO编程、伪异步IO实现
学习基于NIO的同步非阻塞式编程
了解基于NIO2.0的异步非阻塞AIO编程


------------------------------------------
网络编程，传统的socket概念

Socket又称套接字，应用程序通常通过套接字想网络发出请求，或应答往网络的请求

	Socket和ServerSocket类库位于java.net包中。Serversocket用于服务器，
	Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个
	Socket实例，操作这个实例，完成锁需要的会话。对于一个网络连接来说，
	套接字是平等的，不会因为在服务器端或在客户端而产生不同级别。
	不管是socket还是serversocket他们的工作都是通过socketimpl
	类及子类完成
	
	套接字之间的连接过程可以分为四个步骤：服务器监听，客户端请求服务器，服务器确认，客户端确认，进行通信
		（1）服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，
		实时监控网络状态。
		（2）客户端请求：是指由客户端的套接字提出连接请求，要链接的目标是服务器端的套接字。
		为此，客户端的套接字必须首先描述它要链接的服务器套接字，指出服务器
		端套接字的地址和端口号，然后就想服务器端套接字提出连接请求。
		（3）服务器端连接确认：是指当服务器端套接字监听或接受到客户端
		套接字的连接请求，它就相应客户端套接字的请求，建立一个新的线程，
		把服务器端套接字的描述发给客户端。
		（4）客户端连接确认：一旦客户端确认了此描述，连接就建立好了。
		双方开始通信。而服务器端套接字继续处于监听状态，继续接受其他客户端套接字的连接请求。
		
		
		
IO（BIO）和NIO的区别：其本质就是阻塞和非阻塞的区别
	阻塞的概念：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么程序就一直等着
	，知道传输完毕为止。
	非阻塞的概念L应用程序直接可以获取已经准备就绪好的数据，无需等待。
	BIO为同步阻塞形式，NIO为同步非阻塞形式。NIO并没有实现异步，在JDK1.7
	之后升级了NIO包，支持异步非阻塞通信模型即NIO2.0（AIO）
	
	同步和异步：同步和 异步一般是面向操作系统与应用程序对IO操作的层面上来区别的
	同步时：应用程序会直接参与IO读写操作，并且我们的应用程序会直接阻塞到
	某一个方法上，知道数据准备就绪；或者采用轮询的策略实时检查数据的就绪状态，如果就绪
	则获取数据。
	异步时：则所有的IO读写操作交给操作系统处理，与我们的应用程序没有直接关系
	我们的程序不需要关心IO读写，当操作系统完成了IO读写时，会给我们的应用程序发送通知，我们
	直接拿走就是。
	
	
	IO是直接传数据给对方，所以传送数据的过程是阻塞的。
	NIO是先将数据传送到缓冲区，然后再由缓冲区一次性的发到对方，
	
	采用线程池和任务队列可以实现一种伪异步的IO通信框架
	
	NIO模型概念
	有人叫NIO为new IO 如果称为no block io 则更好
	
	学习NIO编程，我们首先要了解几个概念：
	Buffer（缓冲区）、channel（通道）Selector（选择器，多路复用器的概念）
	NIO的本质就是避免原始的TCP建立连接时使用3次握手的操作，减少连接的开销
	
	NIO客户端把通道注册到服务器的多路复用器上（selector），
	以前则是直接建立TCP(3次握手)，NIO的selector不是TCP
	
	
	Buffer是一个对象，它包含一些要写入或要读取的数据。在NIO类库中加入
	Buffer对象，体现了新库与原IO的一个重要的区别。在面向
	流的IO中，可以将数据直接写入或读取到Stream对象中，
	在NIO中，所有数据都是用缓冲区处理的（读写）。缓冲区实质上
	是一个数组，通常它时一个字节数组（ByteBuffer）
	还有其他类型的buffer：
	CharBuffer
	ShortBuffer
	IntBuffer
	....
	除了Boolean类型，其他基本类型都有
	
	Channel。它就像自来水管道一样，网络数据通过channel读取和写入
	，通道与流不同之处在于通道是双向的，
	
	Selector多路复用器，他是NIO编程的基础，非常重要。多路复用器提供选择已经就绪的任务的能力。
	简单说：就是Selector会不断的轮询注册在其上的通道，
	如果某个通道发生了读写操作，这个通道就处于就绪状态，
	会被Selector轮询出来，然后通过Selectionkry可以取得就绪
	的Channel集合，从而进行后续的IO操作。
	
	Selector线程就类似一个管理者（Master），管理了成千上万个通道，然后
	轮询哪个管道的数据已经准备好，通知cpu执行IO的读取或写入操作。
	
	Selector模式：当IO事件（管道）注册到选择器以后，selector
	会分配给每个管道一个key值。selector是一轮询的方式进行查找注册的所有IO事件（通道）
	
	
	
	 position和limit两个变量最重要：
 在写的时候position表示开始写的位置，limit表示能写的最大位置。
 在读的时候position表示开始读取的位置，limit用来表示能够读的最大位置。
 但是读的position和写的position是同一个变量，limit也是。所以写完之后读，和读完之后写都需要手动重置这两个变量。
 所以这两个变量的变化是半自动的：
1）:在allocate（buffer刚分配好空间或者初始化的时候）的时候，position=0；limit=capacity(分配的容量)。


 2）: 在写的时候，刚创建一个buffer，当然要先用来写入一些东西。那么所有的写入操作，都会改变position的位置，position就表示了下一个要写入的位置（是内部一个数组的下标），也表示了已经写入的个数。而limit则不会变化。而position写到limit大小的时候就不会再写入了。当然是否到达需要自己调用remain()判断，不然就异常。


 3)：在读的时候，写过的数据当然要开始读了，但是这个时候，position指向的是下一个要写入的位置，limit指向的是最大容量。我们要读取当然要从0开始读，读到我们最后一个写入的位置。这个时候就需要手动修改position的值，让position=0;我们还要记下我们最后一个写入的位置，那么在positon=0之前，让limit=position，这样，position就是开始读取的位置，limit就是能够读的最大位置。而buffer提供了这样一个方法flip(),源码里就写了这两句：limit=position;position=0;
   接着开始读取，每次读取都会让position位置发生改变，直到读取到limit位置。需要自己调用remain()判断，不然报异常。


 4)：好了，读取过数据我们又需要存储数据了，这就有个问题，如果上次读取没有读取完怎么办？这个烧脑的问题的答案，当然是建议每次都读取完，不要给自己添麻烦。
    接着我们又要往buffer存数据，这个时候position是上次读取的位置，limit是最大可读取位置，全部读取完成position=limit。那么直接往buffer写，就会出错，因为posiont必须小于limit。而我们也想从0位置开始存储，并且需要最大存储限制limit应该是容量capacity。那我们就要手动修改position和limit的数值。让position=0;而limit=capacity;buffer也提供了这个方法clear();
总结：创建一个                         buffer------>存储数据------->调用flip()
                                                      /\                      |
                                                      |         循环          |
                                                      |                       \/
                                                     调用clear()<------读取数据

          当然这是个逻辑清晰的基本操作。掌握了limit,position的含义，理解他们需要手动来改变，你还可以做更多的操作。下载源码，硬着头皮去看，会发现源码注释里面讲的真清晰，图也画的很漂亮。

NIO:概念好理解，实现起来非常复杂，要实现双向通信



AIO:在NIO的基础上引入了异步通道的概念，并提供了异步文件和异步套接字通道的实现
NIO只是非阻塞的，AIO是异步非阻塞