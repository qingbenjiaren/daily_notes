系统架构的发展
	单机系统
	水平扩展，多弄几台机器
	垂直扩展，子系统集群
	
	又分为：服务提供者和服务消费者，微服务架构
	
	服务者和消费者会越来越多
	
	这个时候就有了服务注册中心、服务治理中心，
	可以通过服务治理中心对服务进行调整
	系统容量预估（经验，预估）
	根据服务监控中心，对各个系统进行实时调配
	
	流动计算微服务架构
	
架构师的基本素质：
	常用术语
	（1）：系统容量与系统容量预估
		系统容量指系统锁能承受的最大访问量，而系统容量预估则是在峰值流量到达之前系统架构师锁给出的若干技术指标值
	（2）QPS
		QPS：Query Per Second.每秒查询量。在分布式系统中QPS的定义是，单个进程每秒请求服务器成功次数
		可以使用压测工具测
		QPS = 总请求书/进程总数/请求时间
	（3） UV
		Unique Visitor,独立访客数量
	（4） PV
		Page View
	
	系统容量预估基本计算
		（1）带宽计算
			带宽计算公式：
		（2）并发量计算
		（3）服务器预估量
		

Dubbo简介
	RPC
		底层就是socket
	高性能JAVA RPC框架
		consumer不会被阻塞，因为注册中心会异步通知他
		consumer调用provider是同步的，invoke
		
Dubbo依赖版本
	注册中心是zk
	2.6.1之后的版本用的是curator,之前的版本用的是zkclient
	最高支持的curator版本是2.13.0
	dubbo所依赖的spring是4
	jdk是8
	
直连式Dubbo系统框架搭建



关闭检测

多版本控制和服务分组


负载均衡
	：虚拟主机
	面试题：负载均衡设置在消费者端还是提供者端？答案：都可以，在提供者端设置的负载均衡，最终也会同步到消费者端，而多个提供者的负载均衡策略如果不同，则后加入的
	提供者负载均衡策略会覆盖之前的
	若两端都设置了，则consumer的策略优先于provider的
	而provider的服务级别的策略小于方法级别的策略 
	
	Dubbo的负载均衡和Nginx的负载均衡的区别
	
	
集群容错
	Dubbo内置了6中集群容错策略 

	Failover:（默认） 可以设置在两端，retries = "3"
	Failfast:
		幂等：早请求参数相同的前提下，请求一次与请求n次，对系统的影响是相同的
		GET:幂等
		POST:非幂等（插入）
		PUT:幂等（修改）
		DELETE:幂等
	failsafe:
	failback:
	forking:
	broadcast 
	
解决高并发的三大利器：降级，限流，缓存
	服务降级
		面试题：
			什么是服务降级
				服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，
				以释放服务器资源，保证核心任务的正常运行
				
			服务降级的方式：
				部分服务暂停：双11时，不能修改收货地址
				全部服务暂停：12306 11点后不能买票
				随机拒绝服务：12306，支付时系统忙，请重试
				部分服务延迟：当前系统繁忙，请耐心等待，等待一段时间后，会得到正确的响应
			
			服务降级埋点：静态代理服务器不能做降级
						  消息中间件的埋点，后面给用户的结果是真的结果，只不过结果稍微慢一些
			
			Dubbo的服务降级与Mock机制
				服务降级类似于大厦的应急灯，停电之后至少还能看见路
				Mock NULL和自定义Mock
				
			
		服务调用超时时限
	
	服务限流
		直接限流：通过对连接数量直接进行限制来达到限流的目的（官方方案）
			executes:当前服务的并发执行能力是多少，设置在服务提供者端
			accepts:用于对指定协议的连接数量进行限制，仅提供在端
			actives：两端都可以设置
				设置在提供者端
					根据消费者与提供者间建立的连接类型不同，其意义也不同
					长连接：最多能处理的请求的个数。与长连接的数量没有关系
					短连接：表示当前服务最多能处理的短连接的数量
				设置在消费者端
					长连接：当前消费者所发出的长连接中，最多可以提交的请求的个数，与长连接数量没有关系
					短连接：表示当前消费者可以提交的段连接数量
			connections:两端
				限定连接的个数。
				一般情况下，会使connections与actives联用，
				让connections限制长连接个数，让actives限制一个长连接中可以处理的请求个数
				使用默认的Dubbo协议
			
		间接限流：通过一些非连接数量设置来达到限制流量的目的。 
			延迟连接，延迟加载：可以减少长连接的数量，对长连接其作用
			粘连连接，近设置在消费者端，其会使同一客户端尽量向同一个提供者发起调用，除非宕机，这样可以减少创建长连接的数量，
			只要启用了粘连连接，其会自动启用延迟连接，其限制的是流向而非流量
			负载均衡：可以设置在两端，设置流向，而非流量
				
	声明式缓存：
		保存在消费者端
		 LRU
		 应用场景：
			应用于查询结果不会发生改变的情况，比如查询某个产品的序列号，订单号，身份证号
			
	多注册中心
	
	
	但功能注册中心
		 
		仅订阅
			仅可去发现和调用，但不能被发现。
			其底层实现是当前服务可以从注册中心下载注册列表，但其不会将自己的信息写入到注册列表。
			应用场景：在功能开发完成之前，是不能给其他服务调用的，但是又需要调用注册中心的其他服务，需要下载注册列表，可是一连就注册进去了
			
			设置方式，只需要修改provider的配置文件
				register = "false"
				
		仅注册
			仅可被发现，但不能去发现
			从底层来说就是，当前服务仅可注册到服务中心，不能下载注册列表
			
			subscribe="false"
			
			
		服务暴露延迟
			warmup事件
			
			delay服务暴露延迟
			
			delay
				正数：单位为毫秒，表示在提供者对象创建完毕之后的指定时间后，再发布服务
				0：默认值，表示当前提供者创建完毕后马上向注册中心暴露服务
				-1：表示在Spring容器初始化完毕后再向注册中心暴露服务
				
		消费者的异步调用
		
			Future方式
				修改配置文件
			 
			 CompletableFuture异步调用
				Future调取结果是轮询的方式，占用CPU资源且不具有实时性
				CompletableFuture获取结果是回调的方式，具有实时性
			 
			
			总结：Future和CompletableFuture对比
				Future：是Dubbo2.7.0之前消费者异步调用提供者的实现方式。
					Future源自于JDK5，对异步结果的获取采用了阻塞与轮询的方式。
				CompletableFuture是2.7.0之后的实现方式
					CompletableFuture，源自于JDK8对异步结果的获取采用了回调的方式，不阻塞whenComplete
					
		提供者的异步执行
			
			CompletableFuture.supply
			
			
	Spring Boot中使用Dubbo
		高并发下Redis会出现的问题
			缓存雪崩：很多缓存刚好过期，高并发下的查询都跑到数据库去了，事先规划好过期时间
			缓存穿透：预设值，服务降级
			热点缓存：是缓存雪崩的特例，其中一个热点缓存过期，用双重检测锁的机制，
		
		双重检测锁：解决高并发的问题，使用同步代码阻塞其他线程
			
		@Service
		@Reference
		@CacheEvict
		@Cacheable 
			

github/alibaba

dubbo2.6.4之前的版本用的zk客户端用的树ZkClient


属性配置的优先级
	方法级优先，接口及次之，全局再次之
	若级别一样，消费者优先级高于提供者
	
	配置建议：
		provider上配置合理的provider属性
			在provider上尽量多配置consumer端属性，这让provider一开始就思考在为谁提供服务，提供什么服务，对于提供者来说，更清楚服务应该怎么配置
			provider如果配置了，就算consumer没有配置也可以，相当于一种默认配置
			
			
	
			
	
	
	