课程主题
	设计模式中的创建型设计模式
	
课程目标
	1.掌握三种工程模式：简单工厂，工厂方法和抽象工厂
	2.掌握原型模式
	3.掌握构建者模式
	4.掌握单例模式的两种懒汉式写法：双重检查锁和静态内部类
	5.了解并发编程中的可见性，有序性，原子性
	6.了解volatile关键字的作用
	
课程回顾：
	面向对象的三大特性：
		封装，继承，多态
	面向对象7大设计原则：可维护性和可复用性
		开闭原则：是总纲，最基本原则
		单一职责原则：类如何定义
		接口隔离原则：接口如何定义
		里氏替换原则：如何玩继承
		依赖倒置原则：如何完继承和多态
		合成复用原则：玩类与类的关系
		最少认知原则（迪米特法则）：处理类与类的关系

课程内容：
	设计模式就是遵循了七大设计原则的具体体现，在每个设计模式中，都有设计原则的一些体现
	设计模式分为三类：
		创建型（5种）
		结构型（7种）
		行为型（11种）
		
	创建型设计模式
		创建型设计模式都是为了创建实例对象的。
			1.使用者不需要关系创建对象的细节，直接由创建型设计模式给使用者一个线程的对象。
			2.屏蔽复杂的构造细节
		简单工厂模式
			Spring容器就是通过简单工厂模式去实现的。Spring容器就是管理bean实例的。
			也称为上帝工厂模式。只要给它一个字符串，它就可以给你一个对象
			
			简单工厂模式存在的问题：
				1。违反开闭原则，不利于扩展和维护
				2.入参不明确
				3.使用简单工厂去实现工厂模式，它会很累
				
			如何去解决简单工厂模式的问题
				1.将对象名称和对象通过映射文件（XML）进行配置，读取到内存种建立映射关系
				2.入参不明确，可以将入参设置为要查找对象的类名
				3.通过对象名称，去map集合查找对象，只需要一行代码就够，代码不臃肿
			
			其实除了以上方式，还有工厂方法可以解决简单工厂模式存在的问题
			
		工厂方法模式：
			工厂方法，其实就是教使用者如何建立工厂。如何建立工厂，通过标准接口教给大家
			
			可以解决的问题
				当我们需要创建A产品时，只需要根据工厂方法接口，去创建A产品对应的工厂即可。
				当我们需要B产品时，只需要根据工厂方法接口，去创建B产品对应的工厂即可。
				
		抽象工厂模式
				当我们需要生产产品，是一个产品家族，那么使用工厂方法
				
				
		工厂模式总结：
			1.如果要生产的产品的类型很多的话，建议使用简单工厂
			
			
			
		原型模式：
			其实就是通过复制克隆去重新创建一个一样的对象
			原型模式种包括浅复制（浅拷贝）和深复制（深拷贝）两者实现方式
			浅复制只是对基本类型和string类型进行复制，没有对引用类型进行复制
			深复制指的是对象的所有属性都完全是新的，跟原来的对象没有任何关系
			
			原型模式的优点
			
			
			
			
			浅模式的实现实现Cloneable接口
			
			深复制的实现（ByteArrayOutputString-----> ByteArrayInputStream）
		
		
		构建者模式：
			如果说工厂模式是批量生产产品，那么构建者模式就是可以私人定制产品
			一般来说，读取配置文件产生对象的时候，最好选择构建者模式来构建对象，因为配置文件种配置的信息可有可无
			
			角色：
				产品角色：要构建的对象
				导演角色：
				构建者模式
		
		单例模式：
			两种实现方式：懒汉，饿汉
			
			单例模式的特征：
				1.构造私有
				2.通过静态私有的成员变量去声明实例对象
				3.通过静态公开的成员方法获取实例
			
			如何判断存在线程安全问题？
				1.是否存在共享数据
				2。是否存在多线程
				3.是否是非原子操作的
				
			饿汉式写法：
				线程安全，没有延迟加载
				public class Test01 {
					//第一步：私有构造方法
					private Test01() {}
					//第二步：私有静态属性,类加载时加载
					private static Test01 singleton = new Test01();
					//第三步：共有方法
					public static Test01 getInstance() {
						return singleton;
					}
				}
				//JVM通过类加载器去加载一个类的时候是线程安全的
			
			懒汉式
				延迟加载
					需要同步的懒汉式（简单懒汉式）
					/**
					 * 懒汉式
					 * 延迟加载，线程步安全，访问效率低
					 * @author 24926
					 */
					public class Test02 {
						//私有构造方法
						private Test02() {}
						//私有静态属性，延迟加载
						private static Test02 singleton = null;
						//同步方法
						public synchronized static Test02 getInstance() {
							if(singleton == null) {
								singleton = new Test02();
							}
							return singleton;
						}
					}
					
					私有内部内模式，构建器模式
					/**
					 * 静态内部类的方式（静态的本身就是安全的）
					 * 集合了饿汉式和懒汉式的优点，并且避免了他们的缺点
					 * 线程安全，延迟加载
					 * @author 24926
					 *
					 */
					public class Test04 {
						private Test04() {}
						//构建器模式
						private static class SingletonBuilder{
							private static final Test04 singleton = new Test04(); 
						}
						public Test04 getInstance() {
							return SingletonBuilder.singleton;
						}
					}
					
					双重检查锁
						
				
					
			
			