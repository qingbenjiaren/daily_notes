# 面向对象程序设计基础

**面向对象程序设计**（Object-Oriented Programming， 缩写为OOP） 是一种范式， 其基本理念是将数据块及与数据相关的行为封装成为特殊的、 名为**对象**的实体， 同时对象实体的生成工作则是基于程序员给出的一系列“蓝图”， 这些“蓝图”就是**类**。 

## 对象和类

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\cat.jpg)

假如你有一只名为卡卡的猫。 卡卡是一个对象， 也是 猫 Cat 这个类的一个实例。 每只猫都有许多基本属性： 名字 name 、 性别 sex 、 年龄 age 、 体重 weight 、 毛色 color 和最爱的食物等。 这些都是该类的**成员变量**。 

所有猫都有相似的行为： 它们会呼吸 breathe 、 进食 eat 、 奔跑 run 、 睡觉 sleep 和喵喵叫 meow 。 这 些都是该类的**方法**。

**成员变量和方法可以统称为类的成员。存储在对象成员变量中的数据通常被称为状态，对象中的所有方法则定义了其行为。**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\cats.jpg)

# 优秀设计的特征

## 代码复用

## 扩展性

如果有人要求你对程序进行修改，至少说明还有人关心它

## 面向接口

- 确定一个对象对另一个对象的确切需求：它需要执行哪些方法？
- 在一个新的接口或抽象类中描述这些方法
- 让被依赖的类实现该接口
- 现在让有需求的类依赖于这个接口，而不依赖于具体的类。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\eat.jpg)

完成修改后， 你很可能没法马上看到任何好处； 相反， 代码 会变得比以前更加复杂。 但如果你觉得这里可以是个不错的 额外功能扩展点， 或者其他使用这些代码的用户希望在此进 行扩展的话， 那就马上动手去做吧。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep.jpg)

刚开始时， 公司 Company 类与具体雇员类紧密耦合。 尽 管各个雇员的实现不尽相同， 但我们还是可以归纳出几个与 工作相关的方法， 并且将其抽取为所有雇员的通用接口。

此后， 我们可在 公司 类内应用多态机制， 通过 雇员 Employee 接口来处理各类雇员对象。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep2.jpg)

公司类仍与雇员类相耦合， 这很糟糕， 因为如果引入包含 其他类型雇员的公司类型的话， 我们就需要重写绝大部分的 公司类了， 不能复用其代码。 

为了解决这个问题， 我们可以声明一个抽象方法来获取雇员。 每个具体公司都将以不同方式实现该方法， 从而创建自己所 需的雇员。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep3.jpg)

修改后的公司类将独立于各种雇员类。 现在你可以对该类 进行扩展， 并在复用部分公司基类的情况下引入新的公司和 雇员类型。 对公司基类进行扩展时无需修改任何依赖于基类 的已有代码。 

顺便提一句， 你刚刚目睹的就是设计模式的应用！ 这就是工 厂方法模式的一个示例。 不要担心， 稍后我们会对其进行详 细讨论。

## 组合优于继承

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\transport.jpg)

正如你所看到的， 每个额外参数都将使子类数量倍增。 子类 中将有大量的重复代码， 因为子类不能同时继承两个类。

 你可以使用组合来解决这个问题。 汽车对象可将行为委派给 其他对象， 而不是自行实现。 还有一个好处是你可以在运行时对行为进行替换。 

例如， 你 可以通过重新为汽车对象分配一个不同的引擎对象来替换已 连接至汽车的引擎。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\transport2.jpg)

## SOLID 原则

### Single Responsibility Principle

**修改一个类的原因只能有一个**

当程序规模不断扩大、变更不断增加后，真实问题才会逐渐显现出来。到了某个时候，类会变得过于庞大，以至于你无法记住其细节。查找代码将变得非常缓慢，比必须浏览整个类，甚至整个程序才能找到需要的东西。程序中实体的数量会让你大脑堆栈过载，你会感觉自己对代码失去了控制。还有一点，如果类负责的东西太多，那马当其中任何一件事发生改变时，你都必须对类进行修改。而在进行修改时，你就有可能改动类中自己并不希望改动的部分。

#### 示例

先来看雇员类

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594125741(1).jpg)

我们几个理由来对雇员（Employee）类进行修改。第一个理由与该类的主要工作（管理雇员数据）有关。但还有另一个理由：时间表报告的格式可能会随着事件而改变（与雇员本身无关），从而使你需要对类中的代码进行修改。

解决该问题的方法是将于打印时间表报告相关的行为移动到一个单独的类中。这个改变让你能将其他与报告相关的内容移动到一个新的类中。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594125958(1).jpg)

### Open/closed Principle

**对于扩展，类应该是“开放”的；对于修改，类则应该是“封闭的”。**

本原则的主要理想是在实现新功能时能保持已有代码不变。

如果一个类已经完成开发、 测试和审核工作， 而且属于某个框架或者可被其他类的代码直接使用的话， 对其代码进行修改就是有风险的。 你可以创建一个子类并重写原始类的部分内容以完成不同的行为， 而不是直接对原始类的代码进行修改。 这样你既可以达成自己的目标， 但同时又无需修改已有的原始类客户端。 

#### 示例

你的电子商务程序中包含一个计算运输费用的订单 Order 类，该类中所有运输方法都以硬编码的方式实现。 如果你需要添加一个新的运输方式， 那就必须承担对订单类造成破坏的可能风险来对其进行修改。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594126304(1).jpg)

**你可以通过应用策略模式来解决这个问题。 首先将运输方法抽取到拥有同样接口的不同类中。**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594126447(1).jpg)

现在， 当需要实现一个新的运输方式时，你可以通过扩展运输方式 Shipping 接口来新建一个类， 无需修改任何订单类的代码。当用户在UI中选择这种运输方式时，订单类客户端代码会将订单链接到新类的运输方式对象。 

此外， 根据单一职责原则， 这个解决方案能够让你将运输时 间的计算代码移动到与其相关度更高的类中。

### Liskov Substitution Principle

**当你扩展一个类时，记住你应该要能在不修改客户端代码的情况将子类的对象作为父类对象进行传递。**

替换原则是用于预测子类是否与代码兼容，以及是否能与其超类对象写作的一组检查。这一概念在开发程序库和框架时非常重要，因为其中的类将会在他人的代码中使用，你是无法直接访问和修改这些代码的。

与有着多种解释方式的其他设计模式不同，替代原则包含一组对子类（特别是其方法）的形式要求。

- **子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。**

  - 假设某个类有个方法用于给猫咪喂食：feed(Cat c)。客户端代码总是会将“Cat” 对象传递给方法。
  - **好的方式**：假如你创建了一个子类并重写了前面的方法，使其能够给任何“动物（Animal）：即猫的超类”喂食：feed(Animal c)。如果现在你将一个子类对象而非超类对象传递给客户端代码，程序仍将正常工作。该方法可用于给任何动物喂食，因此它仍然可以用于给传递给客户端的任何“猫”喂食。
  - **不好的方式：**你创建了另一个子类且限制喂食方法仅接受“孟加拉猫（BengalCat，一个“猫”的子类）”：feed(BengalCat c)。如果你用它来替代链接在某个对象中的原始类，客户端会发生什么呢？由于该方法只能对特殊种类的猫进行喂食，因此无法为传递给客户端的普通猫提供服务，从而将破坏所有相关的功能。
  - **对于JAVA语言，重写是要求返回值和参数必须一致，即外壳一样，内核重写**

- **子类方法的返回值类型必须与超类方法的返回值类型或其子类相匹配。**对于返回值类型的要求与对于参数类型的要求相反。

  - 假如你的一个类中有一个方法buyCat():Cat。客户端代码执行该方法后与其返回结果是任意类型的Cat
  - **好的方式**：子类将该方法重写为：buyCat():BengalCat。客户端将获得“孟加拉猫”，自然它也是一只Cat，因此一切正常。
  - **不好的方式**：子类将方法重写为：butCat():Animal。现在客户端代码将会出错，因为它获得的是自己未知的动物种类，不适用于为一只猫而设计的结构。
  - **对于JAVA语言，重写是要求返回值和参数必须一致，即外壳一样，内核重写**

- **子类中的方法不应抛出基础方法预期之外的异常类型。**换句话说，异常类型必须与基础方法的异常相匹配或是其子类。这条规则源于一个事实：客户端代码的try-catch代码块针对的是基础方法可能抛出的异常类型。因此，预期之外的异常可能会穿透客户端的防御代码，从而使整个应用崩溃。

  - **对于绝大部分现代编程语言， 特别是静态类型的编程 语言（Java和C#等等）， 这些规则已内置于其中。 如 果违反了这些规则， 你将无法对程序进行编译。**

- **子类不应该加强其前置条件**。例如，基类的方法有一个int类型的参数。如果子类重写该方法时，要求传递给该方法的参数值必须为正数（如果该值为负数则抛出异常），这就是加强了前置条件。客户端代码之前将负数传递给该方法时程序能够正常运行，但现在使用子类的对象时会使程序出错。

- **子类不能削弱其后置条件**。假如你的某个类中有个方法需要使用数据库，该方法应该在接收到返回值后关闭所有活跃的数据库连接。

  你创建了一个子类并对其进行了修改，是的数据库保持连接以便于重用。但客户端可能对你的意图一无所知。由于它任务该方法会关闭所有的连接 。因此可能会在调用该方法后就马上关闭程序，使得无用的数据库连接对系统造成“污染”。

- **超类的不变量必须保留**

- **子类不能修改超类中私有成员变量的值**。？这难道可能吗？原来有些编程语言允许通过反射机制来访问类的私有成员。还有一些语言（python和javascript）没有对私有成员进行任何保护。

#### 示例

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\里式替换.jpg)

只读文件 ReadOnlyDocuments 子类中的save 方法会在被调用时抛出一个异常。基础方法则没有限制。这以为着如果我们没有在保存前检查文档类型，客户端代码将会出错。

代码也将违反开闭原则，因为客户端代码将依赖于具体的文档类。如果你引入了新的文档子类，则需要修改客户端代码才能对其进行支持。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\里式替换2.jpg)

你可以通过重新设计类层次结构来解决这个问题：一个子类必须扩展其超类的行为，因此只读文档变成了层次结构中的基类。可写文件现在变成了子类，对基类进行扩展并添加了保存行为。

### Interface Segregation Principle

**客户端不应该被强迫依赖于其不使用的方法。**

尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。

根据接口隔离原则， 你必须将“臃肿” 的方法拆分为多个颗 粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。 否则， 对于“臃肿” 接口的修改可能会导致程序出错， 即使 客户端根本没有使用修改后的方法。 

#### 示例

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\接口分离.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\接口分离2.jpg)

### Dependency Inversion Principle

**高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽接口。**

- **低层次的类**实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。
- **高层次类**包含复杂业务逻辑以知道低层次类执行特定操作。

有时人们会先设计低层次的类，然后才会开发高层次的类。当你在新系统上开发原型产品时，这种情况很常见。由于低层次的东西还没有实现或不确定，你甚至无法确定高层次类能实现哪些功能。如果采用这种方式，业务逻辑类可能会更依赖于底层类。

依赖倒置原则通常和开闭原则共同发挥作用： 你无需修改已 有类就能用不同的业务逻辑类扩展低层次的类。 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\依赖倒转.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\依赖倒转2.jpg)



# 设计模式

## 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。

**工厂方法（Factory Method）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法.jpg)

​	在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型

**抽象工厂（Abstract Factory）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂.jpg)

让你能创建一系列相关的对象，而无需指定其具体类。

**生成器（Builder）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器.jpg)

使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

**原型（Prototype）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\原型.jpg)

让你能够复制已有对象，而又无需使代码依赖他们所属的类。

**单例（Singleton）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\单例.jpg)

让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

### 工厂方法

　工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

#### 问题

​    假设你正在开发一款物流管理应用。 最初版本只能处理卡车 运输， 因此大部分代码都在位于名为卡车的类中。

​    一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几 次来自海运公司的请求， 希望应用能够支持海上物流功能。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法1.jpg)

这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部 分代码都与卡车类相关。 在程序中添加轮船类需要修改 全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外 一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。

#### 解决方案

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函 数的直接调用（即使用 new 运算符）。 不用担心， 对象仍将 通过 new 运算符创建， 只是该运算符改在工厂方法中调用 罢了。 工厂方法返回的对象通常被称作“产品”。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法2.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法3.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法4.jpg)

调用工厂方法的代码（通常被称为客户端代码） 无需了解不 同子类返回实际对象之间的差别。 客户端将所有产品视为抽 象的 运输。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法5.jpg)

1. **产品**（Product）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。

2. **具体产品**（Concrete Products）是产品接口的不同实现。

3. **创建者**(Creator)类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。

   你可以将工厂方法声明为抽象方法， 强制要求每个子类以不 同方式实现该方法。 或者， 你也可以在基础工厂方法中返回 默认产品类型。 

   注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， **创建者类包含一些与产品相关的核心业务逻辑**。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 

4. **具体创建者**(Concrete Creators)将会重写基础工厂方法，使其返回不同类型的产品。

   注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂 方法也可以返回缓存、 对象池或其他来源的已有对象。 

#### 伪代码

以下示例演示了如何使用工厂方法开发跨平台UI（用户界 面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法6.jpg)

```java
//程序根据当前配置或环境设定选择创建者的类型
if("Windows".equals(config.OS)){
    dialog = new WindowsDialog();
}else{
    dialog = new WebDialog();
}
```

#### 适合应用场景

- **当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。**

  - 工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。
  - 例如，如果需要向应用中添加一种新产品，只需要开发新的创建者子类，然后重写其工程方法即可。

- **如果你希望用户能扩展你的软件库或框架的内部组件，可使用工厂方法。**

  - 继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识该子类。

  - 解决方案是将个框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写。

    让我们看看具体是如何实现的。 假设你使用开源UI框架编写 自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅 支持矩形按钮。 你可以使用圆形按钮 RoundButton子类来 继承标准的 按钮 Button类。 但是， 你需要告诉 UI框架 UIFramework类使用新的子类按钮代替默认按钮。 

    为了实现这个功能， 你可以根据基础框架类开发 子类 圆形按钮 UI UIWithRoundButtons ， 并且重写其 createButton 创建按钮方法。 基类中的该方法返回 按钮 对象， 而你开发的子类返回圆形按钮对象。 现在， 你就可 以使用圆形按钮 UI 类代替 UI框架类。 就是这么简单！ 

- **如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法**

#### 优缺点

- 避免创建者和具体产品之间的紧密耦合
- **单一职责原则**。你可以将产品创建代码放在程序的单一位置，从而使代码更容易维护
- **开闭原则**。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。
- 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更加复杂。最好的的情况是将该模式引入创建者类的现有层次结构中。

### 抽象工厂

**抽象工厂**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。

#### 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些 类， 用于表示：

-  一系列相关产品， 例如 椅子 Chair 、 沙发 Sofa 和 咖啡桌 CoffeeTable 。 
- 系列产品的不同变体。 例如， 你可以使用 现代 Modern 、 维多利亚 Victorian 、 装饰风艺术 ArtDeco 等风格生成 椅子、 沙发和咖啡桌。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1595233628(1).jpg)

你需要设法单独生成每件家具对象， 这样才能确保其风格一 致。 如果顾客收到的家具风格不一样， 他们可不会开心。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂1.jpg)

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次 更新时都去修改核心代码的。 

#### 解决方案

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继 承这些接口。 例如， 所有风格的椅子都实现椅子接口； 所 有风格的咖啡桌都实现咖啡桌接口， 以此类推

接下来， 我们需要声明抽象工厂——包含系列中所有产品构 造方法的接口。 例如 createChair 创建椅子、 createSofa 创建沙发和 createCoffeeTable 创建咖啡桌。 这些方法必 须返回抽象产品类型， 即我们之前抽取的那些接口： 椅子， 沙发和咖啡桌等等。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂2.jpg)

那么该如何处理产品变体呢？ 对于系列产品的每 个变体， 我们都将基于 抽象工厂 接口创建不同的 工厂类。 每个工厂类都只能返回特定类别的产品， 例如， 现代家具工厂 ModernFurnitureFactory 只能创 建 现代椅子 ModernChair 、 现代沙发 ModernSofa 和 现代咖啡桌 ModernCoffeeTable 对象。 

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你 无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是 维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调 用抽象椅子接口就可以了。 这样一来， 客户端只需知道椅 子以某种方式实现了 sitOn 坐下方法就足够了。 此外， 无 论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创 建的沙发或咖啡桌风格一致。 

最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建 实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段 创建具体工厂对象。 而在此之前， 应用程序必须根据配置文 件或环境设定选择工厂类别。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂3.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\设计模式-抽象工厂.png)

1. **抽象产品**(Abstract Product) 为构成系列产品的一组不同但 相关的产品声明接口。 
2. **具体产品**（Concrete Product） 是抽象产品的多种不同类型实 现。 所有变体（维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。 
3. **抽象工厂**（Abstract Factory） 接口声明了一组创建各种抽象 产品的方法。 
4. **具体工厂**（Concrete Factory） 实现抽象工厂的构建方法。 每 个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必 须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就 不会与工厂创建的特定产品变体耦合。 **客户端（Client）** 只 需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/ 产品变体交互。 

### 伪代码

下面例子通过应用抽象工厂模式， 使得客户端代码无需与具 体UI类耦合， 就能创建跨平台的UI元素， 同时确保所创建 的元素与指定的操作系统匹配。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂4.jpg)

#### 适合应用场景

- **如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者处于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂**
  - 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的 对象。 只要代码通过该接口创建对象， 那么你就不会生成与 应用程序已生成的产品类型不一致的产品。
- **如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式**。
  - 在设计良好的程序中， **每个类仅负责一件事**。 如果一个类与 多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工 厂类或具备完整功能的抽象工厂类中。 

#### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现 这些接口。 
3.  声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组 构建方法。 
4.  为每种产品变体实现一个具体工厂类。 
5.  在应用程序中开发初始化代码。 该代码根据应用程序配置或 当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对 象传递给所有需要创建产品的类。 
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对 工厂对象中相应构建方法的调用。

#### 优缺点

- 你可以确保同一工厂生成的产品相互匹配
- 你可以避免客户端和具体产品代码的耦合
- 单一职责原则。你可以将产品生成代码抽取到同一位置，是的代码易于维护。
- 开闭原则。有应用程序中引入新产品变体时，无需修改客户端代码。



### 生成器

**生成器**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用想用的创建代码生成不同类型和形式的对象。

#### 问题

假设有这样一个复杂对象， 在对其进行构造时需要对诸多成 员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码 通常深藏于一个包含众多参数且让人基本看不懂的构造函数 中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端 代码的多个位置

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器1.jpg)

例如， 我们来思考如何创建一个 房屋 House 对象。 建造 一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门 和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更 宽敞更明亮的房屋， 还要有院子和其他设施（例如暖气、 排 水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展房屋基类， 然后创建一系列涵盖所有 参数组合的子类。 但最终你将面对相当数量的子类。 任何新 增的参数（例如门廊类型） 都会让这个层次结构更加复杂。 

另一种方法则无需生成子类。 你可以在房屋基类中创建一 个包括所有可能参数的超级构造函数， 并用它来控制房屋对 象。 这种方法确实可以避免生成子类， 但它却会造成另外一 个问题。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器2.jpg)

通常情况下， 绝大部分的参数都没有使用， 这使得对于构造 函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。

#### 解决方案

生成器模式建议将对象构造代码从产品类中抽取出来， 并将 其放在一个名为生成器的独立对象中。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器3.jpg)

该模式会将对象构造过程划分为一组步骤， 比如 buildWalls 创建墙壁 和 buildDoor 创建房门 创建房门 等。 每次创建对象时， 你都需要通过生成器对象执行一系列 步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定 对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时， 其中的一些构造步骤可能 需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。 

在这种情况下， 你可以创建多个不同的生成器， 用不同方式 实现一组相同的创建步骤。 然后你就可以在创建过程中使用 这些生成器（例如按顺序调用多个构造步骤） 来生成不同类 型的对象。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器4.jpg)

例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个 建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但 是， 只有在调用构造步骤的客户端代码可以通过通用接口与 建造者进行交互时， 这样的调用才能返回需要的房屋

##### 主管

你可以进一步将用于创建产品的一系列生成器步骤调用抽取 成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而 生成器则提供这些步骤的实现。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器5.jpg)

严格来说， 你的程序中并不一定需要主管类。 客户端代码可 直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放 入各种例行构造流程， 以便在程序中反复使用。 

此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细 节。 客户端只需要将一个生成器与主管类关联， 然后使用主 管类来构造产品， 就能从生成器处获得构造结果了。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器6.jpg)

- **生成器**（Builder）接口声明在所有类型生成器中通用的产品构造步骤。

- **具体生成器**（Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。 
- **产品**（Products） 是最终生成的对象。 由不同生成器构造的 产品无需属于同一类层次结构或接口。 
- **主管**（Director） 类定义调用构造步骤的顺序， 这样你就可以 创建和复用特定的产品配置。 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器7.jpg)

汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有 在汽车类中塞入一个巨型构造函数， 而是将汽车组装代码 抽取到单独的汽车生成器类中。 该类中有一组方法可用来配 置汽车的各种部件。

如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托 给主管类， 因为主管类知道如何使用生成器制造最受欢迎的 几种型号汽车。 

你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一 项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手 册。 当然， 编写手册和制造汽车不是一回事， 所以我们需要 另外一个生成器对象来专门编写使用手册。 该类与其制造汽 车的兄弟类都实现了相同的制造方法， 但是其功能不是制造 汽车部件， 而是描述每个部件。 将这些生成器传递给相同的 主管对象， 我们就能够生成一辆汽车或是一本使用手册了。 

最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存 在关联， 但它们却是完全不同的东西。 我们无法在主管类和 具体产品类不发生耦合的情况下， 在主管类中提供获取结果 对象的方法。 因此， 我们只能通过负责制造过程的生成器来 获取结果对象。

#### 适合应用场景

- **使用生成器模式可避免“重叠构造函数”的出现**

  - 假设你的构造函数中有十个可选参数， 那么调用该函数会非 常不方便； 因此， 你需要重载这个构造函数， 新建几个只有 较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。

- **当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时，可使用生成器模式。**

  - 如果你需要创建的各种形式的产品， 它们的制造过程相似且 仅有细节上的差异， 此时可使用生成器模式。

    基本生成器接口中定义了所有可能的制造步骤， 具体生成器 将实现这些步骤来制造特定形式的产品。 同时， 主管类将负 责管理制造步骤的顺序。 

- **使用生成器构造组合树或其他复杂对象**

  - 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步 骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这 在创建对象树时非常方便。 

    生成器在执行制造步骤时， 不能对外发布未完成的产品。 这 可以避免客户端代码获取到不完整结果对象的情况。 

#### 实现方法

1. 清晰的定义通用步骤，确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。 
2. 在基本生成器接口中声明这些步骤。 
3. 为每个形式的产品创建具体生成器类， 并实现其构造步骤。 
4. 考虑创建主管类。 它可以使用同一生成器对象来封装多种构 造产品的方式。 
5. 客户端代码会同时创建生成器和主管对象。 构造开始前， 客 户端必须将生成器对象传递给主管对象。 通常情况下， 客户 端只需调用主管类构造函数一次即可。 主管类使用生成器对 象完成后续所有制造任务。 还有另一种方式， 那就是客户端 可以将生成器对象直接传递给主管类的制造方法。 
6.  只有在所有产品都遵循相同接口的情况下， 构造结果可以直 接通过主管类获取。 否则， 客户端应当通过生成器获取构造 结果。 

#### 优缺点

可以分步创建对象，暂缓创建步骤或递归运行创建步骤。

生成不同形式的产品，可以复用相同的制造代码

单一职责原则。可以将复杂构造代码从产品的业务逻辑分离出来



### 原型

**原型**也称为克隆，是一种创建型设计模式，能够复制已有对象，而又无需是代码依赖他们所属的类。

#### 问题

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量 值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行 复制， 因为有些对象可能拥有私有成员变量， 它们在对象本 身以外是不可见的。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\原型1.jpg)

直接复制还有另外一个问题。 因为你必须知道对象所属的类 才能创建复制品， 所以代码必须依赖该类。 即使你可以接受 额外的依赖性， 那还有另外一个问题： 有时你只知道对象所 实现的接口， 而不知道其所属的具体类， 比如可向方法的某 个参数传入实现了某个接口的任何对象。

#### 解决方案

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有 支持克隆的对象声明了一个通用接口， 该接口让你能够克隆 对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个克隆方法。

支持克隆的对象即为原型。 当你的对象有几十个成员变量和 几百种类型时， 对其进行克隆甚至可以代替子类的构造。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\原型2.jpg)

其运作方式如下： 创建一系列不同类型的对象并不同的方式 对其进行配置。 如果所需对象与预先配置的对象相同， 那么 你只需克隆原型即可， 无需新建一个对象。 



### 单例模式

**单例模式**是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

#### 问题

单例模式同时解决了两个问题，所以违反了单一职责原则

1. **保证一个类只有一个实例**，客户端甚至可能没有意识到他们一直都在使用同一个对象。
2. **为该实例提供一个全局的访问节点**。

#### 解决方案

所有单例的实现都包含以下两个不同的步骤。

- 将默认构造函数私有化，防止其他对象使用单例类的new运算符
- 新建一个静态构建方法作为构造函数。



## 结构型设计模式

结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\适配器.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\桥接.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\组合.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\外观.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\享元.jpg)



![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\代理.jpg)



### 适配器

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\适配器2.jpg)

**适配器是一种结构型设计模式，它能使接口不兼容的对象能够相互合作**



#### 真实世界类比

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\适配器3.jpg)





### 桥接

桥接是一种结构型设计模式，可将一个大类或一些列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。

#### 问题

假如你有一个几何 形状 Shape 类， 从它能扩展出两个子 类： 圆形 Circle 和 方形 Square 。 你希望对这样的类 层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色 Red 和蓝色 Blue 的形状子类。 但是， 由于你已有 两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例 如蓝色圆形 BlueCircle 和红色方形 RedSquare 。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\桥接1.jpg)

在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色 一个； 此后新增一种新颜色需要新增三个子类， 即每种形状 一个。 如此以往， 情况会越来越糟糕。 

#### 解决方案

**问题的根本原因是我们试图在两个独立的维度--形状与颜色--上扩展形状类。这在处理类继承时是很常见的问题。**

桥接模式通过将继承改为组合的方式来解决这个问题。 具体 来说， 就是抽取其中一个维度并使之成为独立的类层次， 这 样就可以在初始类中引用这个新层次的对象， 从而使得一个 类不必拥有所有的状态和行为。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\桥接2.jpg)

根据该方法， 我们可以将颜色相关的代码抽取到拥有红色 和蓝色两个子类的颜色类中， 然后在形状类中添加一个 指向某一颜色对象的引用成员变量。 现在， 形状类可以将所 有与颜色相关的工作委派给连入的颜色对象。 这样的引用就 成为了形状和颜色之间的桥梁。 此后， 新增颜色将不再 需要修改形状的类层次， 反之亦然。  

#### 适合应用场景

- **如果要拆分或重组一个具有多重功能的庞杂类，可以使用桥接模式**

  - 类的代码行数越多， 弄清其运作方式就越困难， 对其进行修 改所花费的时间就越长。 一个功能上的变化可能需要在整个 类范围内进行修改， 而且常常会产生错误， 甚至还会有一些 严重的副作用。 

    桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可 以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风 险降到最低。 

- **如果在几个独立维度上扩展一个类，可使用桥接模式**

  - 桥接建议将每个维度抽取为独立的类层次。 初始类将相关工 作委派给属于对应类层次的对象， 无需自己完成所有工作

- **如果需在运行时切换不同实现方法，可以使用桥接模式**

  - 当然并不是说一定要实现这一点， 桥接模式可替换抽象部分 中的实现对象， 具体操作就和给成员变量赋新值一样简单。 

  顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的 主要原因。 记住， 设计模式并不仅是一种对类进行组织的方 式， 它还能用于沟通意图和解决问题。

  

#### 实现方式

1.  明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/ 基础设施， 前端/后端或接口/实现。 
2. 了解客户端的业务需求， 并在抽象基类中定义它们。 
3. 确定在所有平台上都可执行的业务。 并在通用实现接口中声 明抽象部分所需的业务。 
4.  为你域内的所有平台创建实现类， 但需确保它们遵循实现部 分的接口。 
5. 在抽象类中添加指向实现类型的引用成员变量。 抽象部分会 将大部分工作委派给该成员变量所指向的实现对象。 
6. 如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每 个变体创建一个精确抽象。 
7. **客户端代码必须将实现对象传递给抽象部分的构造函数才能 使其能够相互关联**。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。 



### 组合

**组合**是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用他们。

#### 问题

如果应用的核心模型能用树状结构表示， 在应用中使用组合 模式才有价值。 

例如， 你有两类对象： 产品和盒子。 一个盒子中可以包 含多个产品或者几个较小的盒子。 这些小盒子中同样 可以包含一些产品或更小的盒子， 以此类推。 

假设你希望在这些类的基础上开发一个定购系统。 订单中可 以包含无包装的简单产品， 也可以包含装满产品的盒子…… 以及其他盒子。 此时你会如何计算每张订单的总价格呢？

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\组合1.jpg)

你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后 计算总价。 这在真实世界中或许可行， 但在程序中， 你并不 能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂 的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。

#### 解决方案

组合模式建议使用一个通用接口来与产品和盒子进行交 互， 并且在该接口中声明一个计算总价的方法。

那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其 价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问 每个项目的价格， 然后返回该盒子的总价格。 如果其中某个 项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项 目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚 至可以在盒子的最终价格中增加额外费用， 作为该盒子的包 装费用。

该方式的最大优点在于你无需了解构成树状结构的对象的具 体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你 只需调用通用接口以相同的方式对其进行处理即可。 当你调 用该方法后， 对象会将请求沿着树结构传递下去。 

#### 实现方式

1. 确保应用的核心模型能够以树状结构表示。 尝试将其分解为 **简单元素和容器。 记住， 容器必须能够同时包含简单元素和 其他容器。**
2. 声明组件接口及其一系列方法， **这些方法对简单和复杂元素 都有意义。**
3. 创建一个叶节点类表示简单元素。 程序中可以有多个不同的 叶节点类。
4. 创建一个容器类表示复杂元素。 在该类中， 创建一个数组成 员变量来存储对于其子元素的引用。 该数组必须能够同时保 存叶节点和容器， 因此请确保将其声明为组合接口类型。
5. 实现组件接口方法时， 记住容器应该将大部分工作交给其子 元素来完成。
6. 最后， 在容器中定义添加和删除子元素的方法。

记住， 这些操作可在组件接口中声明。 这将会违反**接口隔离 原则**， **因为叶节点类中的这些方法为空**。 但是， 这可以让客 户端无差别地访问所有元素， 即使是组成树状结构的元素。

#### 优缺点

1. 可以利用多态和递归机制更方便地使用复杂树结构
2. **开闭原则。** 无需更改现有代码， 你就可以在应用中添加新元 素， 使其成为对象树的一部分。
3. 对于功能差异较大的类， 提供公共接口或许会有困难。 在特 定情况下， 你需要过度一般化组件接口， 使其变得令人难以 理解。



### 装饰

**装饰**是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

#### 问题

假设你正在开发一个提供通知功能的库， 其他程序可使用它 向用户发送关于重要事件的通知。 

库的最初版本基于通知器 Notifier 类， 其中只有很少的几 个成员变量， 一个构造函数和一个 send 发送方法。 该方 法可以接收来自客户端的消息参数， 并将该消息发送给一系 列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作 为客户端的第三方程序仅会创建和配置通知器对象一次， 然 后在有重要事件发生时对其进行调用。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰1.jpg)

此后某个时刻， 你会发现库的用户希望使用除邮件通知之外 的功能。 许多用户会希望接收关于紧急事件的手机短信， 还 有些用户希望在微信上接收消息， 而公司用户则希望在QQ 上接收消息。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰2.jpg)

这有什么难的呢？ 首先扩展通知器类， 然后在新的子类中 加入额外的通知方法。 现在客户端要对所需通知形式的对应 类进行初始化， 然后使用该类发送后续所有的通知消息。 

但是很快有人会问： “为什么不同时使用多种通知形式呢？ 如果房子着火了， 你大概会想在所有渠道中都收到相同的消 息吧。” 

你可以尝试创建一个特殊子类来将多种通知方法组合在一起 以解决该问题。 但这种方式会使得代码量迅速膨胀， 不仅仅 是程序库代码， 客户端代码也会如此。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰3.jpg)

你必须找到其他方法来规划通知类的结构， 否则它们的数量 会在不经意之间打破吉尼斯纪录。

#### 解决方案

当你需要更改一个对象的行为时， 第一个跳入脑海的想法就 是扩展它所属的类。 但是， 你不能忽视继承可能引发的几个 严重问题。

- 继承是静态的。 你无法在运行时更改已有对象的行为， 只能 使用由不同子类创建的对象来替代当前的整个对象。
- 子类只能有一个父类。 大部分编程语言不允许一个类同时继 承多个类的行为。

其中一种方法是用**聚合**或**组合**， 而不是**继承**。 两者的工作 方式几乎一模一样： 一个对象包含指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类 的行为， 它们自己能够完成这些工作。

你可以使用这个新方法来轻松替换各种连接的“小帮手” 对 象， 从而能在运行时改变容器的行为。 一个对象可以使用多 个类的行为， 包含多个指向其他对象的引用， 并将各种工作 委派给引用对象。

**封装器**是装饰模式的别称， 这个称谓明确地表达了该模式的 主要思想。 “封装器” 是一个能与其他“目标” 对象连接的 对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请 求委派给目标前后对其进行处理， 所以可能会改变最终结果。 

那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器 中的引用成员变量可以是遵循相同接口的任意对象。 这使得 你可以将一个对象放入多个封装器中， 并在对象中添加所有 这些封装器的组合行为。

比如在消息通知示例中， 我们可以将简单邮件通知行为放在 基类通知器中， 但将所有其他通知方法放入装饰中。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰4.jpg)

客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰5.jpg)

实际与客户端进行交互的对象将是最后一个进入栈中的装饰 对象。 由于所有的装饰都实现了与通知基类相同的接口， 客 户端的其他代码并不在意自己到底是与“纯粹” 的通知器对 象， 还是与装饰后的通知器对象进行交互。 

我们可以使用相同方法来完成其他行为（例如设置消息格式 或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\装饰6.jpg)

1. **部件**（Component）声明封装器和被封装对象的公用接口
2. **具体部件**(Concrete Component)类是被封装对象所属的类，它定义了基础行为，但装饰类可以改变这些行为。
3. **基础装饰**(Base Decorator)类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。被装饰类会将所有操作委派给被封装的对象。
4. **具体装饰类**(Concrete Decorators)定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为。
5. **客户端**(Client)可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。

#### 适合应用场景

- 如果你希望在无需修改代码的情况下即可使用对象， 且希望 在运行时为对象新增额外的行为， 可以使用装饰模式。
  - 装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装 饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都 遵循通用接口， 客户端代码能以相同的方式使用这些对象。
- 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。
  - 许多编程语言使用 final 最终关键字来限制对某个类的进 一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。

#### 实现方式

1.  确保业务逻辑可用一个基本组件及多个额外可选层次表示。 
2. 找出基本组件和可选层次的通用方法。 创建一个组件接口并 在其中声明这些方法。 
3.  创建一个具体组件类， 并定义其基础行为。 
4. 创建装饰基类， 使用一个成员变量存储指向被封装对象的引 用。 该成员变量必须被声明为组件接口类型， 从而能在运行 时连接具体组件和装饰。 装饰基类必须将所有工作委派给被 封装的对象。 
5. 确保所有类实现组件接口。
6. 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。 
7. 客户端代码负责创建装饰并将其组合成客户端所需的形式。

#### 优缺点

1. 你无需创建新子类即可扩展对象的行为。 
2. 你可以在运行时添加或删除对象的功能。 
3. 你可以用多个装饰封装对象来组合几种行为。 
4. 单一职责原则。 你可以将实现了许多不同行为的一个大类拆 分为多个较小的类。
5. 在封装器栈中删除特定封装器比较困难。
6. 实现行为不受装饰栈顺序影响的装饰比较困难。
7. 各层的初始化配置代码看上去可能会很糟糕。



### 外观

**外观**是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。

#### 问题

假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依 赖关系并按正确的顺序执行方法等。

最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦 合， 使得理解和维护代码的工作很难进行。

#### 解决方案

外观类为包含许多活动部件的复杂子系统提供一个简单的接 口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需 使用其中非常少的功能， 那么使用外观模式会非常方便， 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\外观模式 (1).png)

#### 优缺点

1. 可以让自己的代码福利于复杂子系统。
2. 外观可能成为程序中所有类都耦合的上帝类。



### 享元

**享元**是一种结构型设计模式，它摒弃了再每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态让你能在有限的内存容量中载入更多对象。

#### 问题

假如你希望在长时间工作后放松一下， 所以开发了一款简单 的游戏： 玩家们在地图上移动并相互射击。 你决定实现一个 真实的粒子系统， 并将其作为游戏的特色。 大量的子弹、 导 弹和爆炸弹片会在整个地图上穿行， 为玩家提供紧张刺激的 游戏体验。

开发完成后， 你推送提交了最新版本的程序， 并在编译游戏 后将其发送给了一个朋友进行测试。 尽管该游戏在你的电脑 上完美运行， 但是你的朋友却无法长时间进行游戏： 游戏总 是会在他的电脑上运行几分钟后崩溃。 在研究了几个小时的 调试消息记录后， 你发现导致游戏崩溃的原因是内存容量不 足。 朋友的设备性能远比不上你的电脑， 因此游戏运行在他 的电脑上时很快就会出现问题。

真正的问题与粒子系统有关。 每个粒子（一颗子弹、 一枚导 弹或一块弹片） 都由包含完整数据的独立对象来表示。 当玩 家在游戏中鏖战进入高潮后的某一时刻， 游戏将无法在剩余 内存中载入新建粒子， 于是程序就崩溃了。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\享元1.jpg)

#### 解决方案

仔细观察 粒子 Particle 类， 你可能会注意到颜色（color） 和精灵图（sprite） 这两个成员变量所消耗的内存要比其他变 量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员 变量所存储的数据几乎完全一样（比如所有子弹的颜色和精 灵图都一样）。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\享元2.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\享元3.jpg)



### 代理

**代理**是一种结构型设计模式，让你能够提对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

#### 问题

为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一 个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\代理1.jpg)

你可以实现延迟初始化： 在实际有需要时再创建该对象。 对 象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可 能会带来很多重复代码。 

#### 解决方案

代理模式建议新建一个与原服务对象接口相同的代理类， 然 后更新应用以将代理对象传递给所有原始对象客户端。 代理 类接收到客户端请求后会创建实际的服务对象， 并将所有工 作委派给它

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\代理2.jpg)



#### 代理模式和装饰模式

**装饰**和**代理**有着相似的结构， 但是其意图却非常不同。 这两 个模式的构建都基于**组合原则**， 也就是说一个对象应该将部 分工作委派给另一个对象。 **两者之间的不同之处在于代理通 常自行管理其服务对象的生命周期， 而装饰的生成则总是由 客户端进行控制。**



## 行为模式

行为模式负责对象间高效沟通和职责委派

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\责任链.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\命令.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\迭代器.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\中介.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\备忘录.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\观察者.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\状态.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\策略.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\模板方法.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\访问者.jpg)

### 责任链

**责任链**是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

#### 问题

假如你正在开发一个在线订购系统。 你希望对系统访问进行 限制， 只允许认证用户创建订单。 此外， 拥有管理权限的用 户也拥有所有订单的完全访问权限。

简单规划后， 你会意识到这些检查必须依次进行。 只要接收 到包含用户凭据的请求， 应用程序就可尝试对进入系统的用 户进行认证。 但如果由于用户凭据不正确而导致认证失败， 那就没有必要进行后续检查了。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\责任链1.jpg)

在接下来的几个月里， 你实现了后续的几个检查步骤。 

-  一位同事认为直接将原始数据传递给订购系统存在安全隐患。 因此你新增了额外的验证步骤来清理请求中的数据。
- 过了一段时间， 有人注意到系统无法抵御暴力密码破解方式 的攻击。 为了防范这种情况， 你立刻添加了一个检查步骤来 过滤来自同一 IP 地址的重复错误请求。 
-  又有人提议你可以对包含同样数据的重复请求返回缓存中的 结果， 从而提高系统响应速度。 因此， 你新增了一个检查步 骤， 确保只有没有满足条件的缓存结果时请求才能通过并被 发送给系统。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\责任链2.jpg)

检查代码本来就已经混乱不堪， 而每次新增功能都会使其更 加臃肿。 修改某个检查步骤有时会影响其他的检查步骤。 最 糟糕的是， 当你希望复用这些检查步骤来保护其他系统组件 时， 你只能复制部分代码， 因为这些组件只需部分而非全部 的检查步骤。

系统会变得让人非常费解， 而且其维护成本也会激增。 你在 艰难地和这些代码共处一段时间后， 有一天终于决定对整个 系统进行重构。 

#### 解决方案

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\责任链-1595507893946.jpg)

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\责任链4.jpg)