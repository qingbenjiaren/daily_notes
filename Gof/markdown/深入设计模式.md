# 面向对象程序设计基础

**面向对象程序设计**（Object-Oriented Programming， 缩写为OOP） 是一种范式， 其基本理念是将数据块及与数据相关的行为封装成为特殊的、 名为**对象**的实体， 同时对象实体的生成工作则是基于程序员给出的一系列“蓝图”， 这些“蓝图”就是**类**。 

## 对象和类

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\cat.jpg)

假如你有一只名为卡卡的猫。 卡卡是一个对象， 也是 猫 Cat 这个类的一个实例。 每只猫都有许多基本属性： 名字 name 、 性别 sex 、 年龄 age 、 体重 weight 、 毛色 color 和最爱的食物等。 这些都是该类的**成员变量**。 

所有猫都有相似的行为： 它们会呼吸 breathe 、 进食 eat 、 奔跑 run 、 睡觉 sleep 和喵喵叫 meow 。 这 些都是该类的**方法**。

**成员变量和方法可以统称为类的成员。存储在对象成员变量中的数据通常被称为状态，对象中的所有方法则定义了其行为。**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\cats.jpg)

# 优秀设计的特征

## 代码复用

## 扩展性

如果有人要求你对程序进行修改，至少说明还有人关心它

## 面向接口

- 确定一个对象对另一个对象的确切需求：它需要执行哪些方法？
- 在一个新的接口或抽象类中描述这些方法
- 让被依赖的类实现该接口
- 现在让有需求的类依赖于这个接口，而不依赖于具体的类。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\eat.jpg)

完成修改后， 你很可能没法马上看到任何好处； 相反， 代码 会变得比以前更加复杂。 但如果你觉得这里可以是个不错的 额外功能扩展点， 或者其他使用这些代码的用户希望在此进 行扩展的话， 那就马上动手去做吧。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep.jpg)

刚开始时， 公司 Company 类与具体雇员类紧密耦合。 尽 管各个雇员的实现不尽相同， 但我们还是可以归纳出几个与 工作相关的方法， 并且将其抽取为所有雇员的通用接口。

此后， 我们可在 公司 类内应用多态机制， 通过 雇员 Employee 接口来处理各类雇员对象。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep2.jpg)

公司类仍与雇员类相耦合， 这很糟糕， 因为如果引入包含 其他类型雇员的公司类型的话， 我们就需要重写绝大部分的 公司类了， 不能复用其代码。 

为了解决这个问题， 我们可以声明一个抽象方法来获取雇员。 每个具体公司都将以不同方式实现该方法， 从而创建自己所 需的雇员。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\ep3.jpg)

修改后的公司类将独立于各种雇员类。 现在你可以对该类 进行扩展， 并在复用部分公司基类的情况下引入新的公司和 雇员类型。 对公司基类进行扩展时无需修改任何依赖于基类 的已有代码。 

顺便提一句， 你刚刚目睹的就是设计模式的应用！ 这就是工 厂方法模式的一个示例。 不要担心， 稍后我们会对其进行详 细讨论。

## 组合优于继承

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\transport.jpg)

正如你所看到的， 每个额外参数都将使子类数量倍增。 子类 中将有大量的重复代码， 因为子类不能同时继承两个类。

 你可以使用组合来解决这个问题。 汽车对象可将行为委派给 其他对象， 而不是自行实现。 还有一个好处是你可以在运行时对行为进行替换。 

例如， 你 可以通过重新为汽车对象分配一个不同的引擎对象来替换已 连接至汽车的引擎。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\transport2.jpg)

## SOLID 原则

### Single Responsibility Principle

**修改一个类的原因只能有一个**

当程序规模不断扩大、变更不断增加后，真实问题才会逐渐显现出来。到了某个时候，类会变得过于庞大，以至于你无法记住其细节。查找代码将变得非常缓慢，比必须浏览整个类，甚至整个程序才能找到需要的东西。程序中实体的数量会让你大脑堆栈过载，你会感觉自己对代码失去了控制。还有一点，如果类负责的东西太多，那马当其中任何一件事发生改变时，你都必须对类进行修改。而在进行修改时，你就有可能改动类中自己并不希望改动的部分。

#### 示例

先来看雇员类

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594125741(1).jpg)

我们几个理由来对雇员（Employee）类进行修改。第一个理由与该类的主要工作（管理雇员数据）有关。但还有另一个理由：时间表报告的格式可能会随着事件而改变（与雇员本身无关），从而使你需要对类中的代码进行修改。

解决该问题的方法是将于打印时间表报告相关的行为移动到一个单独的类中。这个改变让你能将其他与报告相关的内容移动到一个新的类中。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594125958(1).jpg)

### Open/closed Principle

**对于扩展，类应该是“开放”的；对于修改，类则应该是“封闭的”。**

本原则的主要理想是在实现新功能时能保持已有代码不变。

如果一个类已经完成开发、 测试和审核工作， 而且属于某个框架或者可被其他类的代码直接使用的话， 对其代码进行修改就是有风险的。 你可以创建一个子类并重写原始类的部分内容以完成不同的行为， 而不是直接对原始类的代码进行修改。 这样你既可以达成自己的目标， 但同时又无需修改已有的原始类客户端。 

#### 示例

你的电子商务程序中包含一个计算运输费用的订单 Order 类，该类中所有运输方法都以硬编码的方式实现。 如果你需要添加一个新的运输方式， 那就必须承担对订单类造成破坏的可能风险来对其进行修改。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594126304(1).jpg)

**你可以通过应用策略模式来解决这个问题。 首先将运输方法抽取到拥有同样接口的不同类中。**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1594126447(1).jpg)

现在， 当需要实现一个新的运输方式时，你可以通过扩展运输方式 Shipping 接口来新建一个类， 无需修改任何订单类的代码。当用户在UI中选择这种运输方式时，订单类客户端代码会将订单链接到新类的运输方式对象。 

此外， 根据单一职责原则， 这个解决方案能够让你将运输时 间的计算代码移动到与其相关度更高的类中。

### Liskov Substitution Principle

**当你扩展一个类时，记住你应该要能在不修改客户端代码的情况将子类的对象作为父类对象进行传递。**

替换原则是用于预测子类是否与代码兼容，以及是否能与其超类对象写作的一组检查。这一概念在开发程序库和框架时非常重要，因为其中的类将会在他人的代码中使用，你是无法直接访问和修改这些代码的。

与有着多种解释方式的其他设计模式不同，替代原则包含一组对子类（特别是其方法）的形式要求。

- **子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。**

  - 假设某个类有个方法用于给猫咪喂食：feed(Cat c)。客户端代码总是会将“Cat” 对象传递给方法。
  - **好的方式**：假如你创建了一个子类并重写了前面的方法，使其能够给任何“动物（Animal）：即猫的超类”喂食：feed(Animal c)。如果现在你将一个子类对象而非超类对象传递给客户端代码，程序仍将正常工作。该方法可用于给任何动物喂食，因此它仍然可以用于给传递给客户端的任何“猫”喂食。
  - **不好的方式：**你创建了另一个子类且限制喂食方法仅接受“孟加拉猫（BengalCat，一个“猫”的子类）”：feed(BengalCat c)。如果你用它来替代链接在某个对象中的原始类，客户端会发生什么呢？由于该方法只能对特殊种类的猫进行喂食，因此无法为传递给客户端的普通猫提供服务，从而将破坏所有相关的功能。
  - **对于JAVA语言，重写是要求返回值和参数必须一致，即外壳一样，内核重写**

- **子类方法的返回值类型必须与超类方法的返回值类型或其子类相匹配。**对于返回值类型的要求与对于参数类型的要求相反。

  - 假如你的一个类中有一个方法buyCat():Cat。客户端代码执行该方法后与其返回结果是任意类型的Cat
  - **好的方式**：子类将该方法重写为：buyCat():BengalCat。客户端将获得“孟加拉猫”，自然它也是一只Cat，因此一切正常。
  - **不好的方式**：子类将方法重写为：butCat():Animal。现在客户端代码将会出错，因为它获得的是自己未知的动物种类，不适用于为一只猫而设计的结构。
  - **对于JAVA语言，重写是要求返回值和参数必须一致，即外壳一样，内核重写**

- **子类中的方法不应抛出基础方法预期之外的异常类型。**换句话说，异常类型必须与基础方法的异常相匹配或是其子类。这条规则源于一个事实：客户端代码的try-catch代码块针对的是基础方法可能抛出的异常类型。因此，预期之外的异常可能会穿透客户端的防御代码，从而使整个应用崩溃。

  - **对于绝大部分现代编程语言， 特别是静态类型的编程 语言（Java和C#等等）， 这些规则已内置于其中。 如 果违反了这些规则， 你将无法对程序进行编译。**

- **子类不应该加强其前置条件**。例如，基类的方法有一个int类型的参数。如果子类重写该方法时，要求传递给该方法的参数值必须为正数（如果该值为负数则抛出异常），这就是加强了前置条件。客户端代码之前将负数传递给该方法时程序能够正常运行，但现在使用子类的对象时会使程序出错。

- **子类不能削弱其后置条件**。假如你的某个类中有个方法需要使用数据库，该方法应该在接收到返回值后关闭所有活跃的数据库连接。

  你创建了一个子类并对其进行了修改，是的数据库保持连接以便于重用。但客户端可能对你的意图一无所知。由于它任务该方法会关闭所有的连接 。因此可能会在调用该方法后就马上关闭程序，使得无用的数据库连接对系统造成“污染”。

- **超类的不变量必须保留**

- **子类不能修改超类中私有成员变量的值**。？这难道可能吗？原来有些编程语言允许通过反射机制来访问类的私有成员。还有一些语言（python和javascript）没有对私有成员进行任何保护。

#### 示例

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\里式替换.jpg)

只读文件 ReadOnlyDocuments 子类中的save 方法会在被调用时抛出一个异常。基础方法则没有限制。这以为着如果我们没有在保存前检查文档类型，客户端代码将会出错。

代码也将违反开闭原则，因为客户端代码将依赖于具体的文档类。如果你引入了新的文档子类，则需要修改客户端代码才能对其进行支持。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\里式替换2.jpg)

你可以通过重新设计类层次结构来解决这个问题：一个子类必须扩展其超类的行为，因此只读文档变成了层次结构中的基类。可写文件现在变成了子类，对基类进行扩展并添加了保存行为。

### Interface Segregation Principle

**客户端不应该被强迫依赖于其不使用的方法。**

尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。

根据接口隔离原则， 你必须将“臃肿” 的方法拆分为多个颗 粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。 否则， 对于“臃肿” 接口的修改可能会导致程序出错， 即使 客户端根本没有使用修改后的方法。 

#### 示例

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\接口分离.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\接口分离2.jpg)

### Dependency Inversion Principle

**高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽接口。**

- **低层次的类**实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。
- **高层次类**包含复杂业务逻辑以知道低层次类执行特定操作。

有时人们会先设计低层次的类，然后才会开发高层次的类。当你在新系统上开发原型产品时，这种情况很常见。由于低层次的东西还没有实现或不确定，你甚至无法确定高层次类能实现哪些功能。如果采用这种方式，业务逻辑类可能会更依赖于底层类。

依赖倒置原则通常和开闭原则共同发挥作用： 你无需修改已 有类就能用不同的业务逻辑类扩展低层次的类。 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\依赖倒转.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\依赖倒转2.jpg)



# 设计模式

## 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。

**工厂方法（Factory Method）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法.jpg)

​	在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型

**抽象工厂（Abstract Factory）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂.jpg)

让你能创建一系列相关的对象，而无需指定其具体类。

**生成器（Builder）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器.jpg)

使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

**原型（Prototype）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\原型.jpg)

让你能够复制已有对象，而又无需使代码依赖他们所属的类。

**单例（Singleton）**

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\单例.jpg)

让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

### 工厂方法

　工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

#### 问题

​    假设你正在开发一款物流管理应用。 最初版本只能处理卡车 运输， 因此大部分代码都在位于名为卡车的类中。

​    一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几 次来自海运公司的请求， 希望应用能够支持海上物流功能。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法1.jpg)

这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部 分代码都与卡车类相关。 在程序中添加轮船类需要修改 全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外 一种运输方式， 很可能需要再次对这些代码进行大幅修改。 最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。

#### 解决方案

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函 数的直接调用（即使用 new 运算符）。 不用担心， 对象仍将 通过 new 运算符创建， 只是该运算符改在工厂方法中调用 罢了。 工厂方法返回的对象通常被称作“产品”。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法2.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法3.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法4.jpg)

调用工厂方法的代码（通常被称为客户端代码） 无需了解不 同子类返回实际对象之间的差别。 客户端将所有产品视为抽 象的 运输。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法5.jpg)

1. **产品**（Product）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。

2. **具体产品**（Concrete Products）是产品接口的不同实现。

3. **创建者**(Creator)类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。

   你可以将工厂方法声明为抽象方法， 强制要求每个子类以不 同方式实现该方法。 或者， 你也可以在基础工厂方法中返回 默认产品类型。 

   注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， **创建者类包含一些与产品相关的核心业务逻辑**。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 

4. **具体创建者**(Concrete Creators)将会重写基础工厂方法，使其返回不同类型的产品。

   注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂 方法也可以返回缓存、 对象池或其他来源的已有对象。 

#### 伪代码

以下示例演示了如何使用工厂方法开发跨平台UI（用户界 面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\工厂方法6.jpg)

```java
//程序根据当前配置或环境设定选择创建者的类型
if("Windows".equals(config.OS)){
    dialog = new WindowsDialog();
}else{
    dialog = new WebDialog();
}
```

#### 适合应用场景

- **当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。**

  - 工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。
  - 例如，如果需要向应用中添加一种新产品，只需要开发新的创建者子类，然后重写其工程方法即可。

- **如果你希望用户能扩展你的软件库或框架的内部组件，可使用工厂方法。**

  - 继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识该子类。

  - 解决方案是将个框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写。

    让我们看看具体是如何实现的。 假设你使用开源UI框架编写 自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅 支持矩形按钮。 你可以使用圆形按钮 RoundButton子类来 继承标准的 按钮 Button类。 但是， 你需要告诉 UI框架 UIFramework类使用新的子类按钮代替默认按钮。 

    为了实现这个功能， 你可以根据基础框架类开发 子类 圆形按钮 UI UIWithRoundButtons ， 并且重写其 createButton 创建按钮方法。 基类中的该方法返回 按钮 对象， 而你开发的子类返回圆形按钮对象。 现在， 你就可 以使用圆形按钮 UI 类代替 UI框架类。 就是这么简单！ 

- **如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法**

#### 优缺点

- 避免创建者和具体产品之间的紧密耦合
- **单一职责原则**。你可以将产品创建代码放在程序的单一位置，从而使代码更容易维护
- **开闭原则**。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。
- 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更加复杂。最好的的情况是将该模式引入创建者类的现有层次结构中。

### 抽象工厂

**抽象工厂**是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。

#### 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些 类， 用于表示：

-  一系列相关产品， 例如 椅子 Chair 、 沙发 Sofa 和 咖啡桌 CoffeeTable 。 
- 系列产品的不同变体。 例如， 你可以使用 现代 Modern 、 维多利亚 Victorian 、 装饰风艺术 ArtDeco 等风格生成 椅子、 沙发和咖啡桌。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\1595233628(1).jpg)

你需要设法单独生成每件家具对象， 这样才能确保其风格一 致。 如果顾客收到的家具风格不一样， 他们可不会开心。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂1.jpg)

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次 更新时都去修改核心代码的。 

#### 解决方案

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继 承这些接口。 例如， 所有风格的椅子都实现椅子接口； 所 有风格的咖啡桌都实现咖啡桌接口， 以此类推

接下来， 我们需要声明抽象工厂——包含系列中所有产品构 造方法的接口。 例如 createChair 创建椅子、 createSofa 创建沙发和 createCoffeeTable 创建咖啡桌。 这些方法必 须返回抽象产品类型， 即我们之前抽取的那些接口： 椅子， 沙发和咖啡桌等等。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂2.jpg)

那么该如何处理产品变体呢？ 对于系列产品的每 个变体， 我们都将基于 抽象工厂 接口创建不同的 工厂类。 每个工厂类都只能返回特定类别的产品， 例如， 现代家具工厂 ModernFurnitureFactory 只能创 建 现代椅子 ModernChair 、 现代沙发 ModernSofa 和 现代咖啡桌 ModernCoffeeTable 对象。 

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你 无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是 维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调 用抽象椅子接口就可以了。 这样一来， 客户端只需知道椅 子以某种方式实现了 sitOn 坐下方法就足够了。 此外， 无 论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创 建的沙发或咖啡桌风格一致。 

最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建 实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段 创建具体工厂对象。 而在此之前， 应用程序必须根据配置文 件或环境设定选择工厂类别。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂3.jpg)

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\设计模式-抽象工厂.png)

1. **抽象产品**(Abstract Product) 为构成系列产品的一组不同但 相关的产品声明接口。 
2. **具体产品**（Concrete Product） 是抽象产品的多种不同类型实 现。 所有变体（维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。 
3. **抽象工厂**（Abstract Factory） 接口声明了一组创建各种抽象 产品的方法。 
4. **具体工厂**（Concrete Factory） 实现抽象工厂的构建方法。 每 个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必 须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就 不会与工厂创建的特定产品变体耦合。 **客户端（Client）** 只 需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/ 产品变体交互。 

### 伪代码

下面例子通过应用抽象工厂模式， 使得客户端代码无需与具 体UI类耦合， 就能创建跨平台的UI元素， 同时确保所创建 的元素与指定的操作系统匹配。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\抽象工厂4.jpg)

#### 适合应用场景

- **如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者处于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂**
  - 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的 对象。 只要代码通过该接口创建对象， 那么你就不会生成与 应用程序已生成的产品类型不一致的产品。
- **如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式**。
  - 在设计良好的程序中， **每个类仅负责一件事**。 如果一个类与 多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工 厂类或具备完整功能的抽象工厂类中。 

#### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现 这些接口。 
3.  声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组 构建方法。 
4.  为每种产品变体实现一个具体工厂类。 
5.  在应用程序中开发初始化代码。 该代码根据应用程序配置或 当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对 象传递给所有需要创建产品的类。 
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对 工厂对象中相应构建方法的调用。

#### 优缺点

- 你可以确保同一工厂生成的产品相互匹配
- 你可以避免客户端和具体产品代码的耦合
- 单一职责原则。你可以将产品生成代码抽取到同一位置，是的代码易于维护。
- 开闭原则。有应用程序中引入新产品变体时，无需修改客户端代码。



### 生成器

**生成器**是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用想用的创建代码生成不同类型和形式的对象。

#### 问题

假设有这样一个复杂对象， 在对其进行构造时需要对诸多成 员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码 通常深藏于一个包含众多参数且让人基本看不懂的构造函数 中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端 代码的多个位置

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器1.jpg)

例如， 我们来思考如何创建一个 房屋 House 对象。 建造 一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门 和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更 宽敞更明亮的房屋， 还要有院子和其他设施（例如暖气、 排 水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展房屋基类， 然后创建一系列涵盖所有 参数组合的子类。 但最终你将面对相当数量的子类。 任何新 增的参数（例如门廊类型） 都会让这个层次结构更加复杂。 

另一种方法则无需生成子类。 你可以在房屋基类中创建一 个包括所有可能参数的超级构造函数， 并用它来控制房屋对 象。 这种方法确实可以避免生成子类， 但它却会造成另外一 个问题。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器2.jpg)

通常情况下， 绝大部分的参数都没有使用， 这使得对于构造 函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。

#### 解决方案

生成器模式建议将对象构造代码从产品类中抽取出来， 并将 其放在一个名为生成器的独立对象中。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器3.jpg)

该模式会将对象构造过程划分为一组步骤， 比如 buildWalls 创建墙壁 和 buildDoor 创建房门 创建房门 等。 每次创建对象时， 你都需要通过生成器对象执行一系列 步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定 对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时， 其中的一些构造步骤可能 需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。 

在这种情况下， 你可以创建多个不同的生成器， 用不同方式 实现一组相同的创建步骤。 然后你就可以在创建过程中使用 这些生成器（例如按顺序调用多个构造步骤） 来生成不同类 型的对象。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器4.jpg)

例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个 建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但 是， 只有在调用构造步骤的客户端代码可以通过通用接口与 建造者进行交互时， 这样的调用才能返回需要的房屋

##### 主管

你可以进一步将用于创建产品的一系列生成器步骤调用抽取 成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而 生成器则提供这些步骤的实现。

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器5.jpg)

严格来说， 你的程序中并不一定需要主管类。 客户端代码可 直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放 入各种例行构造流程， 以便在程序中反复使用。 

此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细 节。 客户端只需要将一个生成器与主管类关联， 然后使用主 管类来构造产品， 就能从生成器处获得构造结果了。

#### 结构

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器6.jpg)

- **生成器**（Builder）接口声明在所有类型生成器中通用的产品构造步骤。

- **具体生成器**（Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。 
- **产品**（Products） 是最终生成的对象。 由不同生成器构造的 产品无需属于同一类层次结构或接口。 
- **主管**（Director） 类定义调用构造步骤的顺序， 这样你就可以 创建和复用特定的产品配置。 

![](D:\kkb\github\daily_notes\Gof\markdown\深入设计模式.assets\生成器7.jpg)

汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有 在汽车类中塞入一个巨型构造函数， 而是将汽车组装代码 抽取到单独的汽车生成器类中。 该类中有一组方法可用来配 置汽车的各种部件。

如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托 给主管类， 因为主管类知道如何使用生成器制造最受欢迎的 几种型号汽车。 

你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一 项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手 册。 当然， 编写手册和制造汽车不是一回事， 所以我们需要 另外一个生成器对象来专门编写使用手册。 该类与其制造汽 车的兄弟类都实现了相同的制造方法， 但是其功能不是制造 汽车部件， 而是描述每个部件。 将这些生成器传递给相同的 主管对象， 我们就能够生成一辆汽车或是一本使用手册了。 

最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存 在关联， 但它们却是完全不同的东西。 我们无法在主管类和 具体产品类不发生耦合的情况下， 在主管类中提供获取结果 对象的方法。 因此， 我们只能通过负责制造过程的生成器来 获取结果对象。

#### 适合应用场景

- **使用生成器模式可避免“重叠构造函数”的出现**

  - 假设你的构造函数中有十个可选参数， 那么调用该函数会非 常不方便； 因此， 你需要重载这个构造函数， 新建几个只有 较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。

- **当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时，可使用生成器模式。**

  - 如果你需要创建的各种形式的产品， 它们的制造过程相似且 仅有细节上的差异， 此时可使用生成器模式。

    基本生成器接口中定义了所有可能的制造步骤， 具体生成器 将实现这些步骤来制造特定形式的产品。 同时， 主管类将负 责管理制造步骤的顺序。 

- **使用生成器构造组合树或其他复杂对象**

  - 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步 骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这 在创建对象树时非常方便。 

    生成器在执行制造步骤时， 不能对外发布未完成的产品。 这 可以避免客户端代码获取到不完整结果对象的情况。 

#### 实现方法

1. 清晰的定义通用步骤，确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。 
2. 在基本生成器接口中声明这些步骤。 
3. 为每个形式的产品创建具体生成器类， 并实现其构造步骤。 
4. 考虑创建主管类。 它可以使用同一生成器对象来封装多种构 造产品的方式。 
5. 客户端代码会同时创建生成器和主管对象。 构造开始前， 客 户端必须将生成器对象传递给主管对象。 通常情况下， 客户 端只需调用主管类构造函数一次即可。 主管类使用生成器对 象完成后续所有制造任务。 还有另一种方式， 那就是客户端 可以将生成器对象直接传递给主管类的制造方法。 
6.  只有在所有产品都遵循相同接口的情况下， 构造结果可以直 接通过主管类获取。 否则， 客户端应当通过生成器获取构造 结果。 

#### 优缺点

可以分步创建对象，暂缓创建步骤或递归运行创建步骤。

生成不同形式的产品，可以复用相同的制造代码

单一职责原则。可以将复杂构造代码从产品的业务逻辑分离出来



### 原型



