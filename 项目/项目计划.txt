项目计划

课程特色
	提升架构高度，仅仅寄希望于代码层级是远远不够的
		代码解决的执行力问题，架构更多的是依赖业务的洞察能力 和 技术事业
	
	课程重点
		架构解决方案
			技术方案落地
		架构背后的思考
		
		核心问题解决方案
	

课程问题
	项目实战 和 其他的 课程到底有什么区别
	课程中是否敲代码？
	
	
	架构师的成长之路
		巨婴：愚昧的山峰，自己不知道自己还不知道
		
		绝望之谷：自信心崩溃，知道自己不知道，知道自己和别人的差距
		
		开悟之坡：积累
		
		大师：持续平稳的高原
		
	持续快速的打造自己
	
架构师什么？
	对业务场景抽象后得出的支持骨架
		老板：100w 日活量，10W QPS 微服务架构
	架构为业务场景而生，被业务场景而弃
		老板：10天上线
	架构没有最好、只有“最合适”（人员技术研发能力，业务复杂度，数据规模大小，时间成本，运维能力。。。）
	
	最合适架构都是业务场景折中的选择
	
		一切脱离业务场景谈架构，都是耍流氓
		
		一切脱离场景谈架构，都是耍流氓
		
		场景驱动架构增长
		
		架构是天时地利人和融合的结果
		
	
	架构一定要选择最合适的架构
	
	
	架构的目标是什么
		用户网站访问调查：rt 3s   60%用户流失
		高性能：前端：美观大气上档次---非常简单，后端：一些列的优化
		高可用：网站任何时候都是可用状态，需要考虑很多因素，硬件，进程，线程，限流，降级
		可伸缩：大促，流量瞬间增大
		可扩展：开发角度（新需求进行迭代），扩展
		安全性：必须
		敏捷性：可持续交付，可持续部署，CI/CD，jekins，docker，k8s
		
	架构的模式
		分层
		分割
		分布
		集群
		缓存：多级缓存，堆内，堆外，redis，memcache
		异步：
		冗余：
		安全：
		自动：
		敏捷：
		
	高性能架构：
	
		可分为前端优化、应用层优化、代码层优化与存储层优化
		
			前端优化：网站业务逻辑之前的部分；----vue，react+nodejs--工厂化
			
			浏览器优化：减少HTTP请求数，使用浏览器缓存，启用压缩，CSS JS异步，减少Cookie传输，CDN加速，反向代理
			
			应用层优化：处理网站业务的服务器。使用缓存，异步，集群
			
			代码优化：合理的架构，多线程，资源复用（对象池，线程池等），良好的数据结构，JVM调优，单例，Cache等
			
			存储优化：缓存、固态硬盘、光纤传输。优化读写、磁盘冗余、分布式存储（HDFS）、NoSQL等
			
	高可用架构
		大型网站应该在任何时候都可以正常访问，正常提供对外服务。因为大型网站的复杂性，分布式u，链家服务器，开源数据库，操作系统等特点，
		要保证高可用是很困难的，也就是说网站的故障是不可避免的。
		
		业务上也需要保证，网站的高可用性。（bug，异常）
		
		对输入有提示，数据有检查，防止数据异常。
		
		系统健壮性强，应该能处理系统运行过程中出现的各种异常情况，如：认为操作错误，输入非法数据、硬件升级失败
		
		因软件系统失效而造成不能完成业务的概率要小于千分之5
		
		要求系统7*24小时运行，全年持续运行故障停运时间累积不超过10小时
		
		系统缺陷率每1000小时最多发生1次故障
		
		在1000000析交易中，最多出现1次需要重新启动
		
		不同的层级使用策略不同，一般采用冗余备份和失效转移解决高可用问题。
		
		应用层：一般设计为无状态，对于每次请求，使用那一台服务器处理是没有影响的，负载均衡
		
		服务层：负载均衡，分级管理，快速失败（超时设置），异步调用，服务降级，幂等设计
		
		数据层：冗余备份
		
		总结：
			集群
			数据冗余
			（网络抖动，请求超时，请求失败）---重试（成功）---可用的
			验证（防止服务漏洞）
			极端异常情况，必须回避----（每一行代码都有可能出现异常，数据一致性）
			缓存
			异步
			
	可伸缩架构
		伸缩性是指在不改变原有架构设计的基础上，通过添加/减少硬件（服务器）的方式，提高/减少系统的处理能力
		
			应用层：对应用进行垂直或水平切分。然后针对单一功能进行负载均衡
			
			服务处：与应用层类似
			
			数据层：分库，分表，NoSQL等，常用算法Hash，一致性Hash
			
			云原生：项目运行在云端，可以随时动态扩容-k8s
			
	可扩展架构
		SOA，微服务----根据业务拆分模块-----新业务需求------根据新的业务需求创建一个新的模块服务
		
		可以方便的进行功能模块的新增/移除，提供代码/模块级别良好的可扩展性
		
		模块化，组件化：高内聚，低耦合，提供复用性，扩展性
		稳定接口：
		设计模式：
		消息队列：
		分布式服务：
		
	安全架构
		对已知问题有有效的解决方案，对未知/潜在
		
		基础设施安全：硬件采购，操作系统，网络环境方面的安全，建立DDOS防御系统，使用攻击检测系统，进行子网隔离等手段
		
		应用系统安全：
		
		数据保密安全：
		
		例如：
		
	敏捷开发：
		敏捷开发 --- 可持续交付，可持续部署 --- 微服务架构
			jekins+maven+git+docker+k8s ============ 流水线生产模式 ==============降本增效
					多干5%的活							运维减少：200% 工作量
				快速上线，快速部署
			
			
	互联网项目	
		互联网的演进	
			[OC internet]PC互联网：让数据可以在一定范围内在线化
		
			[mobile internet]移动互联网：让人越来越多的数据被记录被联通，让数据只能成为可能
		
			[IOT internet of things] 物联网：让网络协同从人扩展到万物
		
		web的演进
			互动1.0
				内容在线
				但互动方式没有变化
				还是一个中心对多点的广播模式
				三大门户
			互动2.0
				以互动为核心
				
				微博、twitter、instagram
				
			互动3.0
				群组和朋友圈
				
				把一对一的关系变成了多对多
				
				微信、facebook
			
			
		发展特点
			
			业务越来越多，越来越复杂
			
			万物互联，数据量越来越大
			
			请求量越来越大更高的用户体验要求
			
			业务快速迭代持续交付功能
			
		
		互联网项目上线的全过程
			客户（老板）需求：造一条船，能过河就好
			
			产品经理：我们可以提供这样的方案----（造一艘豪华游轮，老板很满意）
			
			首席架构师：按需求规划蓝图，架构
			
			高级研发经理：进行项目分解，分模块分给不同的研发团队研发
			
			技术评估：这个项目至少需要1.5年
			
			老板发话：市场不等人，先上线再迭代，给技术团队一个月时间！
			
			研发团队：重新更改设计，马上开始编码（架构比较捡漏，游轮肯定是别想了）
			
			测试团队：提前进入单元测试阶段
			
			测试团队：继承测试
			
			经过一些列的通宵，好几个夜晚都在bug中度过，结果最后造成了个竹筏
			
			船动了，产品实际靠人工拉纤
			
			可怜了这帮人肉运维
			
			市场部：开始对外宣传成功案例（我们的产品是航空母舰）
			
			产品最终靠持续迭代
			
			
	大型互联网公司架构演进思考
		
		架构演进
			单体架构  --->  演进到水平拆分/SOA架构  ------>  微服务架构  --------->  项目架构骨架
			
			云原生时代：
				service mesh
				serverless
				iaas
				paas
				saas
				
			
			
			
		 为什么要从单体架构演进到微服务架构？？
			 1、提供项目并发能力
			 2、CI/CD
			 3、可伸缩可扩展
		
		单体架构：你认为单机并发能力有多少？是否可以做出估算？？
			可以估算：
				服务器：2cpus 4GB --------对这个服务器并发能力估算
				
				前提条件：忽略其他因素的影响（response time，cpu 切换时间），只需要根据内存估算服务器并发能力
				并发：200 QPS	
					静态请求：150 ---- 访问的数据在缓存，不需要读数据库，也就是说不需要把数据放入内存， 一个线程占用1M--2M（经验参考平均值）
					动态请求：50个动态缓存 ------查询数据库，把数据放入内存 ------ 10M（经验参考平均值）
					
					计算：总内存： 150 * 2 + 50 * 10 = 800M
					
					思考：服务器总内存4G，操作系统占用一部分内存，剩下的内存才是服务在使用
						
						800M * 4 = 3.2G（内存） ------200*4 = 800 QPS
						800M * 5 = 4G（内存） ------200*5 = 1000 QPS
						
					2cpus,4GB ----QPS(0,800)----估算值（只考虑内存因素）-----------------实际综合值300（其中还要考虑代码能力的问题，代码烂，rt长）
					4cpus,16GB ----QPS(0,3200)----估算值（只考虑内存因素）---------------实际中和值2000左右（硬件提升，rt更少）
					
				但是实际上不能达到这么多，
					因为，当一个请求来时，执行任务需要时间，执行完了之后还要相应一下，整个过程叫response time
					所以吞吐量要考虑rt，并且还要考虑cpu切换时间
					并发能力影响因素
						1、rt
						2、cpu切换时间
						3、内存
					
					真实结果只能以实际测试结果为准
					
					
			单体架构（没有对业务进行拆分，是单体状态）:
				一个web项目，一个库，
				优点：
					部署简单
					测试简单
					开发简单
					集群简单
					
				缺点：
					无法大规模扩展集群（无法适应海量并发项目）100台服务器并发量在30000
					无法进行可扩展开发
					
				不可替代的优点：RT(response time):响应链路短，响应时间短
					从请求到响应都在本地
					
						1、对于数据实时性要求高的项目，或者要求快速响应的项目，必须采用单体架构。
							比如说：股票，数据不能延迟
						2、对于创业型的公司，采用单体架构也是OK的。
						
					如果并发量超过50000，就困难了
					
			单体架构的优化：
				1）数据库和项目进行分离部署（拆开后，请求链路变长，但是CPU，内存，IO相对来说就可以应对更多的并发请求，rt变长，CPU切换和内存消耗有提升）
				2）单体架构优化-----集群（无状态服务，如果有session请放在redis，如果把session放在服务端，就不好了，很忌讳，服务中不跟数据打交道，不存数据）
						提高网站的并发能力，提高吞吐量，因此使用集群就可以应对大部分网站的需求
					所以应该从业务角度上考虑是否使用单体架构
				3）缓存
					使用memcache，ehcache（堆内存，堆外内存）构建服务缓存。
					降低RT，提供并发能力
				
				5）数据库优化
					分表，分库 很多公司都没有用到这个，包括我们公司
					SQL语句优化
					表设计优化
					索引
				6）CDN缓存， nginx缓存， 浏览器缓存
					进一步减少流到下游的请求
					使用以上的缓存措施，减少请求流入下游服务。减轻下游服务的压力，同时提高项目的并发能力
				
			思考:网站流量越来越大，如何进一步提升网站的并发能力
			
				解决方案：
					无限制的扩展服务器集群规模？-----不行，性能会逐渐下降，为什么会下降：负载仲裁时间？当仲裁时间达到瓶颈，就会下降
						Nginx分发请求，需要去选择一个服务器（选择服务器需要耗时服务器越多，越耗时）：把请求转发过去
						其他因素（成本、是否可行）
					
						
			注意：单体项目必须做集群，因为要考虑单点故障
			
			大批量数据更新：比如每人都有很多优惠券，但是马上就过期，怎么做秒级更新，借助消息中间件来异步修改优惠券状态，这叫消息中间件的服务降级，不需要做实时一致性，做最终一致性
				
				
					
					
				
						
					
					
				
			
	
		