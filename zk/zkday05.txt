Zookeeper典型应用场景----知识点数据模型，watcher机制
	配置维护
		集群的配置文件是相同的，若集群机器非常多，当需要改配置文件的时候，就非常麻烦，
		这个时候就需要利用一个系统来维护，不用手工去改
			可以实现配置维护的技术有很多
				zookeeper
				springcloud
			
			jute.maxbuffer
	命名服务
		什么是命名服务
			
			实现原理
				有序节点路径
				
	DNS服务
		zk的DNS服务主要是解耦提供者和消费者，提供者注册，消费者获取注册列表
		可视化客户端,zooInspector
		状态收集器：定时收集
		状态聚合器：dubbo的管控平台
		
		
		DNS状态收集器的毛病之雷哥之见解：
			状态收集器的定时收集，有毛病，如果刚收集了，其中一台提供者挂了，这个时候信息得不到及时的更新
			
		
		
		用提供者去创建临时节点来替换状态收集器，若提供者挂了，临时节点立马删除，然后在状态
		聚合器上面注册一个watcher监听子节点列表变更，当子节点列表发生变更时产生watcher事件然后出发状态聚合器的回调去更新
		状态
		----我给你鼓个掌，这个临时节点配合watcher监听，太妙了，太妙了，一个女的穿得少，就是一个妙
		这个可以自己去设计，不同的人有不同的设计方案，只要能用好watcher监听用好临时节点，就能设计好应用系统
		
	Master选举
		什么是master选举
		广告推荐系统
			从集群众多节点之间选出一个节点，只做运算，不对外提供服务
			
				让N个节点同时去创建master节点（临时），N个中，只能有一个能创建成功，
				创建成功之后，就作为master节点，若该master挂了之后，让其他节点立马又去抢着创建新的master节点
				这么做，需要客户端都在master节点的父节点上注册watcher事件，监听子节点列表的变更，watcher事件发生之后
				立马去抢着创建新的master
				用zk实现的好处是，master挂了，立马能够重新选举
				
				用mysql也可以，节点全往一张表写同样的数据，用主键唯一来限制只能写成功一条，这样就能选出master，但是，如果master宕机了并不能实时重新选举，
				若要实现，需要写代码去实现，相比zk的临时节点和watcher机制，要复杂得多
				
	分布式同步
		将分布式系统协调的职责从代码中分离出来，在写业务代码的时候，只需要关心具体的业务就行了
		
		MySQL数据复制总线
			用于在不同的MySQL数据库实例间进行异步数据复制，其核心部分由三部分组成，
			还是用到了watcher和临时节点机制，只不过稍微复杂了一些，环环相扣
			关键看，如何去利用zk的特性去设计代码，细节由自己去设计
	
	集群管理：
		临时节点+watcher机制，
		
		分布式日志收集系统
			日志源和收集器的配对问题
			zk关注他们的生存状态
				日志源是临时节点
				收集器是日志源的父节点，持久节点
					那么收集器挂了怎么办？再为收集器建立一个临时节点
					
					监控系统，对持久节点建立子节点列表监听，若子列表发生变化，收集所有的子节点过来，分析挂的是不是收集器，
					若挂的是收集器，则把其他子节点根据负载均衡，分给其他收集器，若挂的是日志源，则是另外的逻辑了（例如，当前收集器负载变小，可以主动去窃取任务）
					
	分布式锁：
		有意思
			控制分布式系统同步访问共享资源的一种方式，根据用户操作类型的不同，可以分为排他锁和共享锁
			
			分布式锁的实现
				分布式系统的性能瓶颈在数据库上，zk实现分布式锁可以减轻数据库的压力
				1.0版本：
				一个客户端来了（读），创建监听，创建临时节点，触发watcher，获得子节点列表，发现自己的最小的
				又来了一个（读），。。。。。发现自己不是最小的，但是前面的节点全是读操作，所以可以读
				又来了一个节点（写）。。。。。发现自己不是最小的，不能写。阻塞
				又来了一个（读）。。。。发现自己不是最小的，发现前面还有小的，并且包含了写，所以阻塞了
				
				羊群效应（惊群），若所有节点都注册了watcher事件，有一个问题，前面每一个执行完了，剩下的节点都会执行回调，但是大部分回调是没意义的
				所以在设计的时候，若集群注册的是子节点列表变更，就会有羊群效应，所以在注册的时候，是不是客户端都的watcher时间都注册到前一个临时节点上就好了
				也不见得，因为若本节点前全是读操作，自己也是读操作，那么监听前一个节点也没有意义
				解决方案：先读子节点列表，若自己没有被阻塞，则不注册监听事件，
				改进版：
				一个客户端来了（读），不创建监听，创建临时节点，触发watcher，获得子节点列表，发现自己的最小的
				又来了一个（读），不创建监听，发现自己不是最小的，但是前面的节点全是读操作，所以可以直接读
				又来了一个节点（写），不创建监听，发现自己不是最小的，不能写，则在离自己最近的节点上创建监听，阻塞
				又来了一个（读）不创建监听，发现自己不是最小的，发现前面还有小的，并且包含了写，注册离自己最近的写操作节点监听，所以阻塞了
				
				
				若2号先执行完，3号怎么办？回调啊，若发现自己不是最小的，则从新注册监听事件
				
	分布式队列
		说道分布式队列，MQ.......Rabbit    Rocket     KAFKA
		
	分布式屏障
		临时节点，监听子节点列表变化，设置阈值，若满足条件，执行逻辑
		
				
			
			
			
				
	
		